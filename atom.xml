<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Markey&#39;s home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.markeyme.cn/"/>
  <updated>2018-03-20T14:43:33.196Z</updated>
  <id>http://blog.markeyme.cn/</id>
  
  <author>
    <name>Markey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://blog.markeyme.cn/2018/03/20/git%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.markeyme.cn/2018/03/20/git总结/</id>
    <published>2018-03-20T12:21:58.963Z</published>
    <updated>2018-03-20T14:43:33.196Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: git总结<br>date: 2018-01-15 23:24:07<br>tags:</p><pre><code>- git- coding</code></pre><hr><h1 id="GIT学习笔记"><a href="#GIT学习笔记" class="headerlink" title="GIT学习笔记"></a>GIT学习笔记</h1><p>仅为本人在工作过程中学习git的一些经验总结，还是git菜鸟一只，有更好的见解欢迎留言 ~</p><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><ol><li>在解冲突时一定要注意，对自己不熟悉的代码要问问是谁写的在解. 如果出现问题，用 git merge –abort 可以将冲突文件退回到merge之前的状态</li><li>在新建一个开发分支时，一定要基于master分支建，不要让其他分支上的代码掺入你的开发分支</li><li>若想更新本地仓库中的分支或tag，用 <strong>git fetch [远程仓库]</strong> 则将远程仓库的所有更新取回本地，<strong>git fetch [远程仓库] &lt;分支名&gt;</strong> 还可以在后面制定分支名，表示只取得该分支的更新，<strong>git fetch –t</strong> 表示取得所有更新及tag</li></ol><h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><ol><li><strong>git config –list</strong> 查看当前的配置项；</li><li><strong>git config –unset [配置键].[配置名]</strong> 删除某项配置；</li><li><strong>git config –global alias.br branch</strong> 设置br为branch命令快捷命令(全局)；</li></ol><h2 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h2><ol><li>要删除远端分支，可以 <strong>git push origin :feature-index-1207</strong>，在分支前加个冒号表示为空分支，推送一个空分支到远端就删除了这个分支；</li><li>git是支持将本地分支push到远程的另一个分支的<br><strong>git push origin develop:master -f</strong><br>将本地的develop push到远端的master分支，<strong>-f为强制标记</strong></li><li><strong>git branch –m 旧分支名 新分支名</strong> 重命名某个分支</li><li>若push之前没有pull远端代码，并且远端有修改的话，是不能push上去的，会提示你先pull再push.</li><li><p><strong>git branch –set-upstream-to origin/[branch]</strong> 设置本地分支跟踪远端分支，<strong>当这样设置后，pull以及push都无需指定origin [branch]了</strong>。</p><blockquote><p><strong>注</strong>：push本地新建的分支到远端，可以用<strong>git push –u origin [branch]</strong>，这样就自动跟踪了远端的这个分支 </p></blockquote></li><li><p><strong>git branch –unset-upstream</strong> 清除当前分支的追踪分支</p></li><li><strong>git branch –track [branch] [remote-branch]</strong> 新建一个本地分支，并与远端分支建立追踪关系</li><li>新建的开发分支不用时刻保持跟master最新的关系，合并到master的时候只是把你的修改合并，并不会将你的分支的其他代码也合并，就是说master中代码还是最新的，并且添加上了你的分支的修改，若有冲突则会合并失败，需要解冲突。</li><li>使用<strong>git rebase [分支名]</strong>“干净地”合并。与merge一样，主要都是为了保持开发分支与master同步。只不过merge会保留很多无用的commit，并且commit的顺序是根据时间排序的，而rebase默认则是将开发分支的commit排在最后（尽管可能commit时间比master某些commit早）。<ul><li>当rebase过程中有冲突时可以用<strong>git rebase –abort</strong>、<strong>git rebase –continue</strong>等命令控制rebase流程</li><li>使用<strong>git rebase -i [分支名]</strong>可以做很多commit相关操作，如可以修改commit message、将多个commit合并为一个等</li></ul></li><li>当本地有修改未添加到暂存区或提交时，会无法checkout到已有分支，而用<strong>git checkout -b [新分支名]</strong>命令切换到新分支则没问题，并会把修改带到新分支<ul><li>该问题也可以使用<strong>git stash</strong>命令解决，该命令将工作区的修改保存，通过<strong>git stash list</strong>可以查看当前保存的所有操作</li><li><strong>git stash pop [stash序号]</strong>恢复保存的工作区修改到当前分支</li><li><strong>git stash clear</strong>清空所有stash</li></ul></li><li><strong>git merge –squash [分支名]</strong>将本地另一个分支所有提交合并为一个，并添加到当前分支的暂存区</li></ol><h2 id="对比及回退"><a href="#对比及回退" class="headerlink" title="对比及回退"></a>对比及回退</h2><ol><li><p>git比对本次跟上次提交的区别: <strong>git diff HEAD HEAD^ –stat</strong>(显示的不详细)；</p><blockquote><p><strong>注</strong>：git diff 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。(若没有提交暂存区，则会比对上次提交的快照)<br></p><p><strong>注</strong>：若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 <strong>git diff –cached</strong> 命令。</p></blockquote></li><li><p><strong>git reset –hard [commit_id]</strong> 回退到某次的commit状态，并将<strong>本地源码也恢复到那次commit的状态</strong><br><br><strong>git reset –soft [commit_id]</strong> 回退到某次的commit状态，但<strong>本地源码保持不变，并保存到暂存区</strong>，如需提交，重新提交即可<br><br><strong>git reset [commit-id]（git reset –mixed [commit-id]）</strong> 回退到某次的commit状态，但本地源码保持不变，如需提交，重新提交即可<br><br><strong>git reset HEAD <file></file></strong> 撤销已暂存的文件<br><br><strong>git reset HEAD~[n]</strong> 撤销到倒数第n次提交<br><br><strong>git checkout <file></file></strong> 摒弃对文件的修改(若无暂存状态，则会退到上次commit；  若有，则回退到上次暂存状态)<br><br><strong>git reset [commit-id | 分支名] <file-name></file-name></strong> 也可以将单个文件恢复到指定提交，但无法使用以上模式，<strong>当前分支修改保持不变，reset到的目标分支加入到暂存区</strong></p><blockquote><p><strong>注</strong>：git reset 到某次commit都会删除git log中那次的commit信息，即回退后就无法再回到之前的commit了<br></p><p><strong>注</strong>：git reset 也可以reset到<em>另一个分支</em>的最后一次提交状态，如: <strong>git reset –hard develop</strong>，同时也可以reset到远端分支的最后一次提交，如<strong>git reset –hard origin/[远端分支名]</strong><br></p></blockquote></li><li><p><strong>git revert HEAD</strong> 回退到最近一次提交的<strong>前一次提交</strong><br><br><strong>git revert HEAD~[n]</strong> 回退到倒数第n次提交的<strong>前一次提交</strong><br><br><strong>git revert [commit_id]</strong> 回退到指定提交的<strong>前一次提交</strong><br></p><blockquote><p><strong>注</strong>：revert相比reset更安全，因为它是生成一次新的提交记录，保留原有的提交记录。</p><p><strong>注</strong>：经测试，这里所说的<strong>前一次提交</strong>是指代码是前一次提交的状态，但显示revert到的commit_id还是指定的commit_id。这一点要跟reset区分开。</p></blockquote></li><li><strong>git commit –amend</strong> 将暂存区中的更改更新到最近一次提交（不会产生新的提交记录）<blockquote><p><strong>注</strong>：若提交时忘了提交某些修改可以用该方法补救</p></blockquote></li><li><strong>git log -p [file]</strong> 查看指定文件每次提交的diff</li><li><strong>git log -g</strong> 按照操作顺序查看所有操作，包括checkout、commit、merge、reset等等。当分支被误删，想要恢复那个分支的代码时，该指令很有效。使用 <strong>git branch [分知名] [commit_id]</strong> 即可恢复分支。<blockquote><p><strong>注</strong>：添加到暂存区是不会有记录的</p></blockquote></li><li><strong>git cherry-pick [commit_id]</strong>可以将其他分支上的提交，在当前分支再提交一次，生成的新commit_id不同</li></ol><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p><strong>原理</strong>：<br><br>你必须为自己创建一对<em>密匙</em>，并把<em>公钥</em>放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，<strong>请求用你的<em>公钥</em>进行安全验证</strong>。服务器收到请求之后，先在你在该服务器的目录下寻找你的<em>公钥</em>，然后把它和你发送过来的公钥进行比较。如果两个一致，服务器就用<strong>公钥加密“质询”（challenge）</strong>并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的<em>密钥解密</em>再把它发送给服务器。<br><strong>SSH key(密钥对)</strong>：<br><br>是git对用户进行身份验证的重要根据，若该用户的电脑上没有ssh key，或者有但是没有添加至ssh agent或你的git account，是无法连接到github进行远端操作的(可通过<strong>ssh -T git@github.com</strong> 命令才验证)<br><br>因此，需要创建ssh key并添加至你的git account。<br>步骤如下：</p><ol><li><strong>本地创建ssh key</strong><br><br>在git bash中输入 <strong>ssh-keygen -t rsa -C “your email address”</strong>命令，然后回车，再输入两次密码即可(该密码在你设置ssh key 到git account时会用到)</li><li><strong>添加到你的ssh agent上</strong><br><br>先检测ssh-agent是否运行 <strong>$ eval $(ssh-agent -s)</strong><br>添加SSH key到ssh-agent <strong>$ ssh-add 你的密钥文件路径(一般是id_rsa)</strong></li><li><p>登录到你的git账户，在settings目录下找到SSH key设置，将你的公钥复制到key选项中，title随意，完事 ~<br></p><blockquote><p><strong>注</strong>：可以通过<strong>ssh-add -l</strong>命令判断当前正在使用的ssh-key，如果有在使用的key，则会输出该key的fingerprint。并且默认的~/.ssh/id_rsa、 ~/.ssh/id_dsa以及 ~/.ssh/identity是自动加入SSH authentication agent的，因此无需再手动ssh-add，如果你使用的是其他名字的key，则要手动加入！</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: git总结&lt;br&gt;date: 2018-01-15 23:24:07&lt;br&gt;tags:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- git
- coding
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h1 id=&quot;GIT学习笔记&quot;&gt;&lt;a href=&quot;#GIT学习笔
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Jimp node-qrcode生成图片并上传总结</title>
    <link href="http://blog.markeyme.cn/2018/03/20/Jimp%20node-qrcode%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E5%B9%B6%E4%B8%8A%E4%BC%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.markeyme.cn/2018/03/20/Jimp node-qrcode生成图片并上传总结/</id>
    <published>2018-03-20T12:01:29.000Z</published>
    <updated>2018-03-20T14:43:42.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node图片处理——Jimp配合node-qrcode生成图片上传总结"><a href="#Node图片处理——Jimp配合node-qrcode生成图片上传总结" class="headerlink" title="Node图片处理——Jimp配合node-qrcode生成图片上传总结"></a>Node图片处理——Jimp配合node-qrcode生成图片上传总结</h1><p>上周产品那边来了一个需求，需要基于原图针对不同用户生成不同二维码以及文案，并生成新图片，让用户能够保存。接到这个需求时，心里不仅没有拒绝的意思，反而有点小兴奋 ~ 因为又能探索一下新东西。</p><p>大致效果如下，原图：</p><p><img style="height: 400px;" src="http://img002.qufenqi.com/products/68/f2/68f2f5b3e0312f25775015cfc42754a0.png"></p><p>效果图：</p><p><img style="height: 400px;" src="http://img002.qufenqi.com/products/5b/bd/5bbdc8add48c51cd5f9a42567ffc8cdd.jpg"></p><h3 id="试水canvas"><a href="#试水canvas" class="headerlink" title="试水canvas"></a>试水canvas</h3><p>刚开始打算在前端用canvas生成图片。我们都知道canvas有合成图片的功能，核心是<code>drawImage</code>及<code>toDataURL</code>这两个方法。</p><p>大致思路是：</p><ol><li>使用<code>drawImage</code>将生成的二维码合并到原图的指定位置</li><li>使用<code>fillText</code>方法生成文案</li><li>用<code>toDataURL</code>将图片转成base64</li><li>使用 atob 以及 Uint8Array 将其转为Buffer进行上传。</li></ol><p>不过最终该方案没有走通，因为不同手机尺寸比例不统一，生成的二维码的位置无法准确地定位到指定位置，因此采用了另一种方案：node层生成图片。</p><h3 id="node搞起"><a href="#node搞起" class="headerlink" title="node搞起"></a>node搞起</h3><p>在node层就无需考虑适配的问题了，因为只有一个基准，也就是原图。生成二维码及文案的尺寸、位置都可以直接写死。经过调研，node图像处理库最出名的有两个，分别是：<a href="https://github.com/oliver-moran/jimp" target="_blank" rel="noopener">Jimp</a> 和 <a href="https://github.com/lovell/sharp" target="_blank" rel="noopener">Sharp</a>，最终选用Jimp，因为Sharp没安装上😓。二维码库倒是很多，最终决定选用 <a href="https://github.com/soldair/node-qrcode" target="_blank" rel="noopener">node-qrcode</a>。</p><p>开搞！</p><p>主要步骤就两步，如下：</p><ol><li>生成图片</li><li>读取图片并上传</li></ol><p>下面分解这两步讲解</p><h4 id="生成图片"><a href="#生成图片" class="headerlink" title="生成图片"></a>生成图片</h4><p>生成图片是最麻烦的。步骤比较多：</p><ol><li>使用qrcode生成二维码 Buffer</li><li>包装二维码Buffer为Jimp对象</li><li>生成文案</li><li>合成图片并保存</li></ol><p>大部分都是调用Jimp及qrcode的api，还有一些node的原生api，如使用<code>Buffer.from</code>将base64转为Buffer。感兴趣的可以去参阅它们的文档：</p><ul><li><a href="https://github.com/oliver-moran/jimp" target="_blank" rel="noopener">Jimp</a></li><li><a href="https://github.com/soldair/node-qrcode" target="_blank" rel="noopener">node-qrcode</a></li><li><a href="http://nodejs.cn/api/buffer.html#buffer_class_method_buffer_from_string_encoding" target="_blank" rel="noopener">Node Buffer</a></li></ul><p>由于生成图片步骤较多，每一步都依赖上一步的结果，并且都是异步的，如果使用回调的话就彻底陷入回调地狱了😓，因此主要想说的是代码组织方式。不怕大家笑话，我的第一版代码是这样的🤣：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成二维码Buffer</span></span><br><span class="line"><span class="keyword">const</span> codeBuffer = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  Qrcode.toDataURL(url, &#123;&#125;, (err, url) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 注意：这里必须把“data:image/png;base64,”这一段去掉才能转成正确的buffer</span></span><br><span class="line">    <span class="keyword">const</span> res = Buffer.from(url.replace(<span class="regexp">/.+,/</span>, <span class="string">''</span>), <span class="string">'base64'</span>)</span><br><span class="line">    err ? reject(err) : resolve(res)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 生成文字</span></span><br><span class="line"><span class="keyword">const</span> textJimp = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> Jimp(textBgWidth, config.textBgHeight, +<span class="string">`0xFF<span class="subst">$&#123;config.textBgColor&#125;</span>`</span>, (err, image) =&gt; &#123;</span><br><span class="line">    Jimp.loadFont(config.fontPath).then(<span class="function">(<span class="params">font</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(image.print(font, config.textPadding, <span class="number">10</span>, textContent, <span class="number">10</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 将二维码Buffer包装成Jimp对象</span></span><br><span class="line"><span class="keyword">const</span> codeJimp = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  Jimp.read(codeBuffer).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">      resolve(res.resize(config.codeWidth, config.codeWidth))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      reject(<span class="string">'包装buffer失败'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  Jimp.read(config.originImgPath).then(<span class="function"><span class="params">img</span> =&gt;</span> &#123;</span><br><span class="line">    img.composite(codeJimp, config.codeLeft, config.codeTop)</span><br><span class="line">       .composite(textJimp, config.textLeft, config.textTop)</span><br><span class="line">       <span class="comment">// 由于fs.createReadStream不能接受Buffer作为参数，只能将生成的图片临时保存到本地</span></span><br><span class="line">       .write(config.tempFilePath, () =&gt; &#123;</span><br><span class="line">         <span class="comment">// resolve()</span></span><br><span class="line">         reject(<span class="string">'保存图片失败！'</span>)</span><br><span class="line">       &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'保存图片出错：'</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为我们使用的node前后端分离框架 <a href="https://github.com/xiongwilee/Gracejs" target="_blank" rel="noopener">grace</a> 的版本是支持 generator 语法的，所以想到了使用 yield 来将异步操作同步展示，但还是看起来太繁琐了😓，必须重构！</p><p>promise 登场！</p><p>使用 promise 的链式调用语法，结构就会清晰很多，改写后代码是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合多个异步I/O</span></span><br><span class="line"><span class="keyword">const</span> imgResult = <span class="keyword">yield</span> generateCode(href)</span><br><span class="line">  <span class="comment">// 生成二维码Buffer</span></span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    codeBuffer = res;</span><br><span class="line">    <span class="comment">// 包装二维码Buffer为Jimp对象</span></span><br><span class="line">    <span class="keyword">return</span> wrapCodeBuffer(codeBuffer, imgConfig);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    codeJimp = res;</span><br><span class="line">    <span class="comment">// 生成文字</span></span><br><span class="line">    <span class="keyword">return</span> generateText(textBgWidth, textContent, imgConfig);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    textJimp = res;</span><br><span class="line">    <span class="comment">// 组合并生成图片</span></span><br><span class="line">    <span class="keyword">return</span> compositeImg(imgConfig, textJimp, codeJimp);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 成功</span></span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">true</span>)</span><br><span class="line">  <span class="comment">// 中途出错</span></span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>瞬间优雅的许多 ~<br>实现方法也很简单，就是让每个步骤的方法都返回一个 promise 即可，拿该方法为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包装二维码Buffer为Jimp对象</span></span><br><span class="line"><span class="comment"> * @param  &#123;Buffer&#125; codeBuffer  [二维码Buffer对象]</span></span><br><span class="line"><span class="comment"> * @param  &#123;Object&#125; config      [配置对象]</span></span><br><span class="line"><span class="comment"> * @return &#123;Promise&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapCodeBuffer</span>(<span class="params">codeBuffer, config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    Jimp.read(codeBuffer).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        resolve(res.resize(config.codeWidth, config.codeWidth));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">'包装二维码Buffer失败'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h4><p>接下来是使用node上传图片。由于使用的后端接口是基于FormData方式的，所以要在node层模拟一个FormData上传请求。<br>起初是完全懵逼的，因为对http协议的这块标准一直是一知半解。在前端使用FormData上传图片时我们经常能看到请求体是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">------WebKitFormBoundarywQMoN5B2ZNAD6uqN</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;avatar.jpeg&quot;</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundarywQMoN5B2ZNAD6uqN--</span><br></pre></td></tr></table></figure><p>请求头的Content-Type是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundarywQMoN5B2ZNAD6uqN</span><br></pre></td></tr></table></figure><p>看起来挺复杂的，尤其是这个<code>------WebKitFormBoundarywQMoN5B2ZNAD6uqN--</code>到底是个什么鬼😢。</p><p>别急，先从我的这个上传方法讲起：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传图片方法</span></span><br><span class="line"><span class="comment"> * @param  &#123;ClientRequest&#125; request  [由http.request方法返回的对象]</span></span><br><span class="line"><span class="comment"> * @param  &#123;Object&#125;        config   [配置对象]</span></span><br><span class="line"><span class="comment"> * @param  &#123;String&#125;        cookies  [用户请求时所带的所有cookie]</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uploadImg</span>(<span class="params">request, config, cookies = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 模拟form-data请求后端接口上传图片</span></span><br><span class="line">  <span class="keyword">const</span> boundaryKey = <span class="built_in">Math</span>.random().toString(<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">const</span> endData = <span class="string">'\r\n----'</span> + boundaryKey + <span class="string">'--'</span>;</span><br><span class="line">  <span class="keyword">let</span> contentLength = <span class="number">0</span>,</span><br><span class="line">      content = <span class="string">''</span>;</span><br><span class="line">  content += <span class="string">'\r\n----'</span> + boundaryKey + <span class="string">'\r\n'</span> +</span><br><span class="line">            <span class="string">'Content-Type: application/octet-stream\r\n'</span> +</span><br><span class="line">            <span class="string">'Content-Disposition: form-data; name="file"; '</span> +</span><br><span class="line">            <span class="string">'filename="bg_invite.png"; \r\n'</span> +</span><br><span class="line">            <span class="string">'Content-Transfer-Encoding: binary\r\n\r\n'</span>;</span><br><span class="line">  <span class="keyword">let</span> contentBinary = Buffer.from(content, <span class="string">'utf-8'</span>);</span><br><span class="line">  <span class="comment">// 获取上传内容总大小</span></span><br><span class="line">  contentLength = fs.statSync(config.tempFilePath).size + Buffer.byteLength(contentBinary) + Buffer.byteLength(endData);</span><br><span class="line">  <span class="comment">// 设置请求头</span></span><br><span class="line">  request.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'multipart/form-data; boundary=--'</span> + boundaryKey);</span><br><span class="line">  request.setHeader(<span class="string">'Content-Length'</span>, contentLength);</span><br><span class="line">  request.setHeader(<span class="string">'Cookie'</span>, cookies);</span><br><span class="line">  request.write(contentBinary);</span><br><span class="line">  <span class="keyword">const</span> fileStream = fs.createReadStream(config.tempFilePath, &#123; <span class="attr">bufferSize</span>: <span class="number">4</span> * <span class="number">1024</span> &#125;);</span><br><span class="line">  fileStream.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    request.end(endData);</span><br><span class="line">  &#125;);</span><br><span class="line">  fileStream.pipe(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个方法其实就是构造了请求，拆分下来就如下几件事：</p><ul><li>构造请求头</li><li>计算上传内容总大小</li><li>将文件以流的形式写入<a href="http://nodejs.cn/api/http.html#http_class_http_clientrequest" target="_blank" rel="noopener">http.ClientRequest</a>对象</li></ul><p>先说请求头，FormData形式的请求Content-Type为<code>multipart/form-data</code>，并且一定要提供<code>boundary</code>字段。可是为什么呢？</p><p>我们都知道默认提交表单时，Content-Type是<code>application/x-www-form-urlencoded</code>，并且参数都是已类似<code>name=John&amp;age=12</code>这种形式在请求体中传递的，参数是以<code>&amp;</code>分割的。这里的<code>boundary</code>的作用就跟<code>&amp;</code>一样，是用来分割多个参数的，并且是可以自定义的，而在浏览器中，是浏览器为我们自动生成的，这就知道了上文中那个<code>boundary</code>是怎么回事了 ~</p><p>再看每个<code>boundary</code>之间的内容，也就是每个字段，其中还有Content-type及Content-Disposition字段我们很陌生。</p><p>Content-Type跟http协议的Content-Type是一样的，只不过在<code>multipart/form-data</code>类型中，我们可以手动指定每个参数的Content-Type。方法中的字段值为<code>application/octet-stream</code>，就是告诉Server这部分内容是字节流，因为我们需要以字节流的形式上传图片。</p><p>而Content-Disposition是每个参数必须的选项，并且值必须为<code>form-data</code>。该头其实还有其他用途，可以参阅<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition" target="_blank" rel="noopener">MDN的官方文档</a>。</p><p>接下来是计算Content-Length。这里主要使用了node的<a href="http://nodejs.cn/api/fs.html" target="_blank" rel="noopener">fs模块</a>，以及<a href="http://nodejs.cn/api/buffer.html" target="_blank" rel="noopener">Buffer模块</a>的api，都很好理解，查看文档即可。</p><p>最后是将图片写入http.ClientRequest对象中。该对象是由node的http.request方法返回，并且是一个可写流。引用<a href="http://nodejs.cn/api/http.html#http_http_request_options_callback" target="_blank" rel="noopener">node官方文档</a>的话：</p><blockquote><p>ClientRequest 实例是一个可写流。 如果需要通过 POST 请求上传一个文件，则写入到 ClientRequest 对象。</p></blockquote><p>最后再调用http.ClientRequest对象的end方法，即可完成请求对象的写入，就发出请求啦 ~</p><p>至此，一个Node合成图片并上传的需求完成！过程中收获非常多！</p><p>生命不息折腾不止！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Node图片处理——Jimp配合node-qrcode生成图片上传总结&quot;&gt;&lt;a href=&quot;#Node图片处理——Jimp配合node-qrcode生成图片上传总结&quot; class=&quot;headerlink&quot; title=&quot;Node图片处理——Jimp配合node-q
      
    
    </summary>
    
    
      <category term="node" scheme="http://blog.markeyme.cn/tags/node/"/>
    
      <category term="coding" scheme="http://blog.markeyme.cn/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>观《盲山》有感</title>
    <link href="http://blog.markeyme.cn/2018/03/03/%E8%A7%82%E3%80%8A%E7%9B%B2%E5%B1%B1%E3%80%8B%E6%9C%89%E6%84%9F/"/>
    <id>http://blog.markeyme.cn/2018/03/03/观《盲山》有感/</id>
    <published>2018-03-03T13:40:29.000Z</published>
    <updated>2018-03-05T01:45:49.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="观《盲山》有感"><a href="#观《盲山》有感" class="headerlink" title="观《盲山》有感"></a>观《盲山》有感</h1><blockquote><p>不是影评，只是观后感</p></blockquote><p>今天看了《盲山》后，心情无比压抑。虽然这部电影的故事已经耳熟能详，无论电视上还是网络中已经有过各种拐卖妇女的报道，所以从一开始就基本能想到剧情的发展方向，但是过程中依旧被种种场景震撼，比如雪梅逃出屋子后被全村的男人联合抓回，村里其他被拐卖妇女劝说雪梅她们是如何屈服的，警察来到村里营救却被村民围堵威胁导致营救失败等等。电视上对这类报道听得多了，就会有些麻木，但看了这部电影不得不赞叹导演对各种细节的精妙表述，能够切身体会到被拐妇女的绝望，不得不给给李杨导演点个赞。<br></p><h2 id="先说说让我印象最深刻的几个男人"><a href="#先说说让我印象最深刻的几个男人" class="headerlink" title="先说说让我印象最深刻的几个男人"></a>先说说让我印象最深刻的几个男人</h2><h3 id="黄德贵"><a href="#黄德贵" class="headerlink" title="黄德贵"></a>黄德贵</h3><p>无论酒桌上的这句“谁不喝完这酒，谁就一辈子打光棍，儿子孙子也打光棍，下辈子还是打光棍！”，还是被雪梅劝说时的强词夺理“坐个球的牢，哪家娶媳妇不花钱”，都能看出这个人的“盲”。在他眼里，女人就是自己的工具、仆人，结婚也不过是花一笔钱就了了的事。他不知道什么叫拐卖妇女，因为村里人都这么干；他也不知道结婚是有法律效益的，是两情相悦的，因为他“经验丰富”的父亲就是认为“女人就要收拾”。生长环境的“盲”导致了他的“盲”，并且会继续传递下去，恶性循环。也许帮雪梅寄信的刘青山长大后也娶了买来的媳妇。</p><h3 id="黄父"><a href="#黄父" class="headerlink" title="黄父"></a>黄父</h3><p>刚开始感觉这个老人看起来还是挺老实憨厚的，直到他为了帮他无能的儿子“办事”，跟黄母一块控制雪梅好让黄德贵强奸她后，彻底颠覆了对他印象。而且在德贵办完事后还赞许地给他递支烟，仿佛认可德贵的能力一样，顿时让我感觉一阵恶心。</p><h3 id="黄德诚"><a href="#黄德诚" class="headerlink" title="黄德诚"></a>黄德诚</h3><p>刚开始觉得这个人可能是雪梅的最后救星，他是全村看起来唯一有点良知的。看到后面才发现，无论是以救雪梅逃出去为名义而摸她的手，还是最后直接搞了雪梅的身子，这个人的那点学问全都用在了虚伪上。<br><br>最后事情败露，不仅让雪梅再次挨了打，之后为了逃避责任抛弃了雪梅，一个人离开了村子。雪梅逃出去最大的希望破灭。他所说的“道德的德，诚信的诚”真是对他一个天大的讽刺。<br><br>可能有人觉得雪梅是真心喜欢他，或者只是为了逃出去而利用他，无论怎样，最终受伤的依旧是雪梅。德诚走后，雪梅没有哭没有闹，只是静静地烧掉了他送的书，然后来到小卖铺跟老板做了“交易”。在经历了那么多事以后，她已经开始麻木，习惯了受伤，但唯一让我庆幸的是，她始终没有放弃抵抗。相比村里其他被拐卖来的女人，雪梅无疑是坚强的。<br><br>后来看了影评后惊了，才发现那个扮演同样被拐卖来的女人的演员就是真实被拐卖来，生活在那个村子里的，并且才20岁就已经是两个孩子的妈。</p><h2 id="其他人"><a href="#其他人" class="headerlink" title="其他人"></a>其他人</h2><p>无论是帮德贵将雪梅抓回去的男人们、眼睁睁看着雪梅的求救而不予帮助的村委会主任，还是看似礼貌实则被买通的邮递员、猥琐的小卖部老板等等，整部电影把村民的无知、冷漠、法盲血淋淋地展现到底。<br><br>最可怕的是当警察来救雪梅时，全村人集体出动阻挠，甚至以动武威胁。德贵无视警察的手枪，“犯啥法？你打，朝这打”，黄母也耍起无赖，“你们要把人带走，从我身上压过去算了”。看到这里突然觉得似曾相识。即使身处城市的我们，隔三差五依旧能看到类似的人、事。<br><br>不得不说，李杨是勇敢的，将社会最真实的一面毫无粉饰地展示出来。即使是现在，中国拐卖妇女的现象依旧存在，而且屡见不鲜。就同电影一样，村中的人们不认为这是犯法，而是天经地义，甚至就在电影拍摄时就有当地村民恬不知耻地问李杨：“那个女娃娃（女主角）长得不错，干脆就卖给我吧。”他们被山遮蔽了双眼，不以无知为耻，麻木不仁，上下同谋。<br><br>起初我心里是无比的愤怒，但是看到黄母为了不让雪梅堕胎而给雪梅下跪我又有了反思。村民们想要的无非是传宗接代，尽管他们的道德观不符合现代的标准，但他们的目的也不过如此。所谓“穷山恶水出刁民”，我认为村民的暴力，也是由于极度的不安全感。因为长期的与世隔绝，他们知道自己是跟不上时代的，是社会的最弱者，所以只能通过暴力、无赖来声明自己的权益。其实仔细想一想，他们不是不知道拐卖妇女是犯法，而是选择麻木，上下一气，因为他们都是一条绳上的蚂蚱。他们是既可恨又可悲的。<br><br>所以整部电影的罪人，我认为非人贩子莫属。</p><h2 id="再说雪梅"><a href="#再说雪梅" class="headerlink" title="再说雪梅"></a>再说雪梅</h2><p>其实电影中雪梅的设定是大学生就让我有些怀疑，因为即使是90年代，大学生也不至于会轻易相信一个人贩子的话到山里吧，要知道90年代的大学生是多么稀有，能力多强不说，至少在最基础的判断力上也不会那么愚蠢。<br><br>不过可能电影就是这样，不能以过分理性的眼光去评判，只要体会到导演想传达的感情和思想就可以了。从这个角度看，雪梅无疑是悲惨的，尤其是海外版结局，最终一刀砍向德贵。她的命运依旧没有被改变。不过这也更加贴近现实。毕竟被强制封闭在这山里那么久，忍受身体、精神上的虐待，经历种种绝望，她心里一定早有怒火，只是无法宣泄。从电影中雪梅给德贵拿毛巾那处就可以看出，她其实早有杀掉德贵的念头。即使是大学生，处在那样充满暴力的环境中久了，也会被同化，因为那里只有暴力才能解决问题。<br><br>对这个角色，我不想多说，只是替她惋惜。有哪个女生不希望自己能够享受更好的物质生活，能够嫁给自己心爱的人，如果她没有轻信人贩子，她的生活会是无限美好的，前途也是不可限量的。正是这种巨大的反差突出了这种矛盾。随着剧情的发展，看着雪梅一步步从清纯的少女，到年仅20多岁就看起来像大婶，心里无比叹息。<br><br>而目前在中国，依然有很多这样活生生的例子，它们也许就发生在我们老家，也许就是哪个婶婶、奶奶，就如上文说的村中其他被拐卖进来的女人一样，她们不像雪梅，大多数只能选择妥协，甚至有些还觉得在那里挺好。<br><br>有趣的是，影片最后打了一行字幕：“中国公安机关一直严厉打击拐卖妇女的犯罪活动，解救出无数被拐卖的妇女，并将犯罪分子绳之以法。”怎么看怎么像是讽刺。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;观《盲山》有感&quot;&gt;&lt;a href=&quot;#观《盲山》有感&quot; class=&quot;headerlink&quot; title=&quot;观《盲山》有感&quot;&gt;&lt;/a&gt;观《盲山》有感&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;不是影评，只是观后感&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天看了《
      
    
    </summary>
    
    
      <category term="movies" scheme="http://blog.markeyme.cn/tags/movies/"/>
    
  </entry>
  
  <entry>
    <title>好好写代码</title>
    <link href="http://blog.markeyme.cn/2018/02/08/%E5%A5%BD%E5%A5%BD%E5%86%99%E4%BB%A3%E7%A0%81%E5%BD%92%E6%A1%A3/"/>
    <id>http://blog.markeyme.cn/2018/02/08/好好写代码归档/</id>
    <published>2018-02-08T06:30:16.000Z</published>
    <updated>2018-02-09T08:50:16.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="好好写代码"><a href="#好好写代码" class="headerlink" title="好好写代码"></a>好好写代码</h1><p>作为一个刚写代码不久的小菜鸟，工作的半年多让我越发意识到提高代码质量的重要性。从前只会关注实现功能，慢慢的开始关注性能，现阶段则发现其实还有很多细节也是（如可读性、易用性、可维护性、一致性）提高代码质量的关键。“实现功能”跟“优雅地实现功能”是两码事。</p><p>大部分归纳自网络，将多篇文章的观点汇总加工了一下，也融合了一些个人的见解。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ul><li>单一职责原则</li><li>易用性原则</li><li>可读性原则</li><li><p>复杂性守恒原则：无论你怎么写代码，复杂性都是不会消失的</p><blockquote><p>注：如果逻辑很复杂，那么代码看起来就应该是复杂的。如果逻辑很简单，代码看起来就应该是简单的。</p></blockquote></li></ul><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>面向对象五大设计模式基本原则之一。即<strong>一部分代码只应该用于某一个特定功能，不应与其他功能耦合在一起</strong>。</p><p>假设你的一个function同时实现了功能a和功能b，之后需求变更，你需要修改功能a，但是因为这两个功能都在一个function里，你就不得不再去确认是否会影响到功能b。这就造成了不必要的成本。</p><p>如下我总结了三个拆分代码的原则：</p><h4 id="“and”原则"><a href="#“and”原则" class="headerlink" title="“and”原则"></a>“and”原则</h4><p>当你为你的方法命名时不得不加上“and”时，就该考虑考虑是不是要把这个方法拆分一下了。</p><h4 id="“100”原则"><a href="#“100”原则" class="headerlink" title="“100”原则"></a>“100”原则</h4><p>当你的一个function超过一百行时，一定要进行拆分了。</p><blockquote><p>注：这里的100可能有点多，只是对我个人而言，100算是我的极限，总之就是绝对不要将一个函数写的太长。</p></blockquote><h4 id="命令、查询拆分原则"><a href="#命令、查询拆分原则" class="headerlink" title="命令、查询拆分原则"></a>命令、查询拆分原则</h4><p>我们开发中大部分操作可以总结为“命令”和“查询”，如写cookie、修改data、发送post请求都可以叫“命令”，而读取cookie、ajax获取数据则认为是“查询”操作。</p><p>函数式编程中讲究“数据不可变”，即：</p><blockquote><p>只有纯的没有副作用的函数，才是合格的函数。</p><p>副作用：指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量）或修改参数。</p></blockquote><p>好处是使得开发更加简单，可回溯，测试友好，减少了任何可能的副作用。</p><p>将“命令”与“查询”拆分实际上就是函数式编程思想的部分体现，参考如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> firstName = <span class="built_in">document</span>.querySelector(<span class="string">"#firstName"</span>).value;</span><br><span class="line">    firstName = firstName.toLowerCase();</span><br><span class="line">    setCookie(<span class="string">"firstName"</span>, firstName);</span><br><span class="line">    <span class="keyword">if</span> (firstName === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> activeFirstName = getFirstName();</span><br></pre></td></tr></table></figure><p>通过名字来看，该方法是用于获取first name的，但实际上它还设置了cookie，这是我们没有预料的。对于一个“查询”方法，它不应该有任何修改方法外变量的行为，即“副作用”。更好的写法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> firstName = <span class="built_in">document</span>.querySelector(<span class="string">"#firstName"</span>).value</span><br><span class="line">    <span class="keyword">if</span> (firstName === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">setCookie(<span class="string">"firstName"</span>, getFirstName().toLowerCase());</span><br></pre></td></tr></table></figure><p>一目了然，getFirstName只返回firstName，而设置cookie操作在它之外进行。</p><h3 id="易用性原则"><a href="#易用性原则" class="headerlink" title="易用性原则"></a>易用性原则</h3><h4 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h4><p>这里的简单，主要归结为function的一些设计原则，有如下几点：调用简单、易理解、减少记忆成本、参数处理。</p><p>如下，仅仅想实现修改dom颜色、宽度等属性，原生代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#id'</span>).style.color = <span class="string">'red'</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#id'</span>).style.width = <span class="string">'123px'</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#id'</span>).style.height = <span class="string">'456px'</span></span><br></pre></td></tr></table></figure><p>而封装过后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">selector, color, width, height</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).style.color = color</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).style.width = width</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).style.height = height</span><br><span class="line">&#125;</span><br><span class="line">a(<span class="string">'#a'</span>, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><p>瞬间变得<strong>简单可用</strong>了 ~</p><p>但该方法还存在一个问题，那就是命名太抽象了。。。除了开发者自己以外不可能有人在不看源码的情况下一眼看出这个方法a是干嘛的。那么咱再把这个方法名改写得更<strong>易理解</strong>一点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">letSomeElementChange</span>(<span class="params">selector, color, width, height</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).style.color = color</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).style.width = width</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).style.height = height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就能一目了然该方法的作用 ~ 不过仍有可优化的地方。这么长的方法名谁记得住，要<strong>减少记忆成本</strong>啊，再改个名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setElement</span>(<span class="params">selector, color, width, height</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).style.color = color</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).style.width = width</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).style.height = height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，目前这个方法已经满足它的职责并且很好用了，但还觉得怪怪的。这一坨参数太碍眼。。。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setElement</span>(<span class="params">selector, opt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; color, width, height &#125; = opt</span><br><span class="line">  color &amp;&amp; <span class="built_in">document</span>.querySelector(selector).style.color = color</span><br><span class="line">  width &amp;&amp; <span class="built_in">document</span>.querySelector(selector).style.width = width</span><br><span class="line">  height &amp;&amp; <span class="built_in">document</span>.querySelector(selector).style.height = height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把多个参数合并一下，并在内部做兼容处理，这个方法便易用多了。即使不传第二个参数也不会有任何副作用。</p><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>假如有这样一个方法，获取歌曲列表，并将其设置到div的innerText中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSongs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> $.get(<span class="string">'/songs).then((response) &#123;</span></span><br><span class="line"><span class="string">      div.innerText = response.songs</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这就违背了方法的<strong>表里一致性</strong>，也违背了上文的<strong>单一职责原则</strong>中<strong>命令、查询拆分原则</strong>，因为它不仅获取了歌单，同时还修改了innerText，要让其更合理：</p><ul><li>要么换个名字</li><li>要么拆分为两个方法</li></ul><h4 id="低耦合"><a href="#低耦合" class="headerlink" title="低耦合"></a>低耦合</h4><p><strong>耦合是衡量一个程序单元对其他程序单元的依赖程度</strong>。耦合（或高耦合）是应该极力避免的。如果你发现自己正在复制和粘贴代码并进行小的更改，或者重写代码，因为其他地方发生了更改，这就是高耦合的体现。</p><p>耦合会严重影响代码的复用性及可扩展性，让后人维护时不得不修改甚至重写这部分代码，不仅浪费时间还会导致仓储中又多出一块类似的代码，很容易让人迷惑。</p><p>同时，修改耦合度高的代码时经常会牵一发而动全身，如果修改时没有理清这些耦合关系，那么带来的后果可能会是灾难性的，特别是对于需求变化较多以及多人协作开发维护的项目，修改一个地方会引起本来已经运行稳定的模块错误，严重时会导致恶性循环，问题永远改不完，开发和测试都在各种问题之间奔波劳累，最后导致项目延期，用户满意度降低，成本也增加了，这对用户和开发商影响都是很恶劣的，各种风险也就不言而喻了。</p><h4 id="高内聚"><a href="#高内聚" class="headerlink" title="高内聚"></a>高内聚</h4><blockquote><p><strong>不应该将没有任何联系的东西堆到一起。</strong></p></blockquote><p><strong>内聚是一个类中变量与方法连接强度的尺度</strong>。高内聚是值得要的，因为它意味着类可以更好地执行一项工作。低内聚是不好的，因为它表明类中的元素之间很少相关。每个方法也应该高内聚，大多数的方法只执行一个功能，不要在方法中添加‘额外’的指令，这样会导致方法执行更多的函数，同时也违反了上文的<strong>单一职责原则</strong>。</p><p><strong>低内聚的体现</strong>：如果属性没有被类中的多个方法使用，这可能是低内聚的标志。同样，如果方法在几种不同的情况下不能被重用，或者如果一个方法根本不被使用，这也可能是低内聚的一个标志。</p><p><strong>高内聚有助于缓解高耦合，高耦合是需要高内聚的标志</strong>。但是，如果两个问题同时存在，应当选择内聚的方式。对于开发者来说，高内聚通常比低耦合更有帮助，尽管两者通常可以一起完成。</p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><ul><li>可预见的错误：诸如ajax回调、函数参数，这类问题很好解决，只需在开发时多考虑一步，对各种极端情况做好兼容即可。</li><li>不可预见的错误：类似兼容性问题，这类问题无法在开发时准确预见的错误，可以准备好抛错，console.error/log/warn，最后你还可以为自己的程序留些后路: try…catch。</li></ul><h3 id="可读性原则"><a href="#可读性原则" class="headerlink" title="可读性原则"></a>可读性原则</h3><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>命名应该保证别人通过名称一眼就能知道这个变量保存的是什么，或者这个方法是用来做什么的。</p><ul><li><p>普通变量、属性用名词如下：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Frank'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> student = &#123;</span><br><span class="line">    grade: <span class="number">3</span>,</span><br><span class="line">    class: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>bool变量、属性用（形容词）或者（be动词）或者（情态动词）或者（hasX），如下：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    dead: <span class="literal">false</span>, <span class="comment">// 如果是形容词，前面就没必要加 is，比如isDead 就很废话</span></span><br><span class="line">    canSpeak: <span class="literal">true</span>, <span class="comment">//情态动词有 can、should、will、need 等，情态动词后面接动词</span></span><br><span class="line">    isVip: <span class="literal">true</span>, <span class="comment">// be 动词有 is、was 等，后面一般接名词</span></span><br><span class="line">    hasChildren: <span class="literal">true</span>, <span class="comment">// has 加名词</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>普通函数、方法用（动词）开头：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    run()&#123;&#125;, <span class="comment">// 不及物动词</span></span><br><span class="line">    drinkWater()&#123;&#125;, <span class="comment">// 及物动词</span></span><br><span class="line">    eat(foo)&#123;&#125;, <span class="comment">// 及物动词加参数（参数是名词）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回调、钩子函数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    beforeDie()&#123;&#125;,</span><br><span class="line">    afterDie()&#123;&#125;,</span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    willDie()&#123;&#125;</span><br><span class="line">    dead()&#123;&#125; <span class="comment">// 这里跟 bool 冲突，你只要不同时暴露 bool dead 和函数 dead 就行，怕冲突就用上面的 afterDie</span></span><br><span class="line">&#125;</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, onButtonClick)</span><br><span class="line"><span class="keyword">var</span> component = &#123;</span><br><span class="line">    beforeCreate()&#123;&#125;,</span><br><span class="line">    created()&#123;&#125;,</span><br><span class="line">    beforeMount()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>命名一致性</p><ul><li>顺序一致性：比如 updateContainerWidth 和 updateHeightOfContainer 的顺序就令人很别扭</li><li><strong>时间一致性</strong>：有可能随着代码的变迁，一个变量的含义已经不同于它一开始的含义了，这个时候你需要及时改掉这个变量的名字。<br>这一条是最难做到的，因为写代码容易，改代码难。如果这个代码组织得不好，很可能会出现牵一发而动全身的情况（如全局变量就很难改）</li></ul></li></ul><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>不需要多花哨，只要把作用、用法描述清楚即可。方法的标准注释应该如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [function_name description]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; argument [description]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;          [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_name</span>(<span class="params">argument</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将方法的参数与返回值都写清楚，我目前用的IDE是sublime，使用<a href="https://atom.io/packages/docblockr" target="_blank" rel="noopener">Docblockr</a>插件可以自动生成格式化注释，很方便。</p><h3 id="Bad-Smell"><a href="#Bad-Smell" class="headerlink" title="Bad Smell"></a>Bad Smell</h3><p>项目中我们经常能够遇这类代码，它们仍可用，但是很“臭”，国外管这类代码有一个统称，即“bad smell”。如下这类代码可以说是很“臭”了：</p><ul><li>表里不一的代码</li><li>过时的注释</li><li>逻辑很简单，但是看起来很复杂的代码</li><li>重复的代码</li><li>相似的代码</li><li>总是一起出现的代码</li><li>未使用的依赖</li><li>不同风格的代码</li></ul><h3 id="样式规范"><a href="#样式规范" class="headerlink" title="样式规范"></a>样式规范</h3><ol><li><strong>正确命名</strong>：class必须用“-”写法，不要用驼峰和下划线。</li><li><strong>正确嵌套</strong>：正常情况下一定要将class嵌套闭合，否则就相当于添加到全局，如果有重复命名的class就会受影响。</li><li><strong>拒绝copy</strong>：如果想复用已有的样式，直接在原有class上用“,”语法分割，就能应用，不要再copy一份样式，会让两份样式都被应用，就要考虑样式覆盖的问题，很不友好。</li><li><strong>滥用class</strong>：没有必要加的class不要加，每个class的添加都应该有明确理由。滥用class的话可能会导致样式覆盖，不该应用这个样式的地方用了某个样式。</li><li><p>慎用 <strong>!important</strong>，会强行覆盖所有同属性样式，一旦使用后会让代码难以维护，开发过程中绝对不要依赖该方法。如下总结了一些使用 <strong>!important</strong>的经验：</p><ul><li>一定要优化考虑使用样式规则的优先级来解决问题而不是 !important</li><li>只有在需要覆盖全站或外部 css（例如引用的 ExtJs 或者 YUI ）的特定页面中使用 !important</li><li>解决紧急线上问题可以使用，但之后也要尽快用可维护的方式将代码替换回来</li><li>永远不要在全站范围的 css 上使用 !important</li><li>永远不要在你的插件中使用 !important</li></ul></li></ol><h2 id="说得容易，做起来难"><a href="#说得容易，做起来难" class="headerlink" title="说得容易，做起来难"></a>说得容易，做起来难</h2><h3 id="破窗效应"><a href="#破窗效应" class="headerlink" title="破窗效应"></a>破窗效应</h3><blockquote><p>此理论认为环境中的不良现象如果被放任存在，会诱使人们仿效，甚至变本加厉。一幢有少许破窗的建筑为例，如果那些窗不被修理好，可能将会有破坏者破坏更多的窗户。最终他们甚至会闯入建筑内，如果发现无人居住，也许就在那里定居或者纵火。一面墙，如果出现一些涂鸦没有被清洗掉，很快的，墙上就布满了乱七八糟、不堪入目的东西；一条人行道有些许纸屑，不久后就会有更多垃圾，最终人们会视若理所当然地将垃圾顺手丢弃在地上。这个现象，就是犯罪心理学中的<strong>破窗效应</strong>，在编程领域同样存在。</p></blockquote><p>要做到：<strong>只要是经过你手的代码，都会比之前好一点。</strong></p><p>参考文章：</p><ul><li><a href="http://www.cnblogs.com/constantince/p/5580003.html" target="_blank" rel="noopener">javascript的api设计原则</a></li><li><a href="http://alistapart.com/article/coding-with-clarity" target="_blank" rel="noopener">Coding with Clarity</a></li><li><a href="https://dev.to/raulavila/dont-leave-broken-windows" target="_blank" rel="noopener">Don’t leave broken windows</a></li><li><a href="https://segmentfault.com/a/1190000008780076" target="_blank" rel="noopener">从JS对象开始，谈一谈“不可变数据”和函数式编程</a></li><li><a href="https://segmentfault.com/a/1190000012972191" target="_blank" rel="noopener">重构 - 代码优化技巧</a></li><li><a href="https://www.w3cplus.com/css/the-important-css-declaration-how-and-when-to-use-it.html" target="_blank" rel="noopener">如何和何时使用CSS的!important</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity" target="_blank" rel="noopener">css优先级</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;好好写代码&quot;&gt;&lt;a href=&quot;#好好写代码&quot; class=&quot;headerlink&quot; title=&quot;好好写代码&quot;&gt;&lt;/a&gt;好好写代码&lt;/h1&gt;&lt;p&gt;作为一个刚写代码不久的小菜鸟，工作的半年多让我越发意识到提高代码质量的重要性。从前只会关注实现功能，慢慢的开始关注性
      
    
    </summary>
    
    
      <category term="coding" scheme="http://blog.markeyme.cn/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>markey</title>
    <link href="http://blog.markeyme.cn/2018/01/16/markey/"/>
    <id>http://blog.markeyme.cn/2018/01/16/markey/</id>
    <published>2018-01-16T13:13:16.000Z</published>
    <updated>2018-01-17T14:05:25.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小站终于搭好啦"><a href="#小站终于搭好啦" class="headerlink" title="小站终于搭好啦"></a>小站终于搭好啦</h1><p>为了纪念这意义重大的时刻，一定要写篇文章庆祝下，主题不是别的，就是我。</p><h2 id="歪某某—-一个努力的前端程序猿兼鼓手"><a href="#歪某某—-一个努力的前端程序猿兼鼓手" class="headerlink" title="歪某某— 一个努力的前端程序猿兼鼓手"></a>歪某某— 一个努力的前端程序猿兼鼓手</h2><p>称谓：</p><ul><li>大头（因为姓氏的缘故，这个昵称是被用的最久的，贯穿我的整个童年、少年时代…）</li><li>歪**（高中时开始用，主要在网上用，没什么含义，好玩而已）</li><li>markey（码名：即作为开发者的昵称）</li></ul><p>2017年6月25日毕业于东北林业大学，信息管理与信息系统专业（一半计算机一半管理）。大学期间没参与任何校组织（因为觉得官僚），倒是把一大半精力放在了社团上，一个是异族摇滚社，一个是606软件工作室。可以说这两个社团的经历决定了我现在的路。</p><p>学生时代喜欢安静，不太参与社交，造成了现在表达能力欠佳。很多时候想法有了，不知如何表达，非常无奈啊。工作后这个问题更加凸显出来，最近正在慢慢改进。</p><p>从小到大就一直有股倔劲，对于自己喜欢的事，非常执着、我行我素。学生时代可以总结为这几件事：</p><ul><li>小学：魔兽3、cs</li><li>初中：篮球</li><li>高中：学习</li><li>大学：音乐、前端</li></ul><p>小学时是个网瘾少年，立志成为sky那样的电竞选手，天天打魔兽、cs。自以为在朋友圈中水平尚佳，但也因此成绩渣的一逼，升学考试没能进入重点班。</p><p>初中渐渐放弃电竞，又开始沉迷篮球，模板为NBA伟大射手Ray.Allen。初二还参加过训练营，见识到世界之大后备受打击，遂专心学习。</p><p>高中时代由于篮球打得还行，学习成绩也不错，先后被几个妹子暧昧，但没一个有结果。那时候脑子里就只有学习…情商啊…</p><p>附一张高中时代仅有的图，被邻桌偷拍的：<br><img src="/assets/high_school.jpeg" alt="高中"></p><p>大学时的经历着实决定了我现在的方向。加入了异族摇滚社让我体会到了责任与担当，也给予了我终生的爱好；加入软件工作室让我接触了前端，进入了互联网行业，也学会了一门养活自己的本事。</p><p>因为喜欢日本视觉系摇滚，大学演出特意让左边这个漂亮的妹子给画了个非常视觉系的浓妆…后来还画过几次，但都没这次成功。<br><img src="/assets/college_1.jpeg" alt="浓妆"></p><p>如今，已工作半年，每天沉迷工作无法自拔，只想努力成长，早日成为大牛。之后有时间了，还计划继续玩个乐队，没事儿录个视频、排排练，也是极好的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;小站终于搭好啦&quot;&gt;&lt;a href=&quot;#小站终于搭好啦&quot; class=&quot;headerlink&quot; title=&quot;小站终于搭好啦&quot;&gt;&lt;/a&gt;小站终于搭好啦&lt;/h1&gt;&lt;p&gt;为了纪念这意义重大的时刻，一定要写篇文章庆祝下，主题不是别的，就是我。&lt;/p&gt;
&lt;h2 id=&quot;歪某
      
    
    </summary>
    
    
      <category term="life" scheme="http://blog.markeyme.cn/tags/life/"/>
    
  </entry>
  
</feed>
