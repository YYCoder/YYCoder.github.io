<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Markey&#39;s home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.markeyme.cn/"/>
  <updated>2019-03-03T05:31:39.674Z</updated>
  <id>https://blog.markeyme.cn/</id>
  
  <author>
    <name>Markey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shadowsocks翻墙原理探究</title>
    <link href="https://blog.markeyme.cn/2019/02/28/shadowsocks%E7%BF%BB%E5%A2%99%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>https://blog.markeyme.cn/2019/02/28/shadowsocks翻墙原理探究/</id>
    <published>2019-02-28T12:38:30.000Z</published>
    <updated>2019-03-03T05:31:39.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shadowsocks翻墙原理探究"><a href="#Shadowsocks翻墙原理探究" class="headerlink" title="Shadowsocks翻墙原理探究"></a>Shadowsocks翻墙原理探究</h1><p>Shadowsocks 是目前公认的科学上网神器，由 <a href="https://github.com/clowwindy" target="_blank" rel="noopener">clowwindy</a> 开发，它的出现极大地便利了广大程序猿们，让我们能够绕过 GFW 方便地访问 google 或 youtube 等国际大型网站。它的核心原理是<strong>基于 Socks5 代理协议的网络数据加密传输</strong>，具体在下面会做进一步介绍。</p><p>本文会以如下目录依次展开：</p><ul><li>GFW</li><li>Socks5协议</li><li>Shadowsocks工作原理</li><li>Shadowsocks源码解析</li></ul><hr><h2 id="GFW"><a href="#GFW" class="headerlink" title="GFW"></a>GFW</h2><p>全称是 Great Firewall of China，国内一般称作“防火墙”或俗称“墙”，正是因为这个东西的存在，让整个中国大陆区域内的网络受其控制，成为了众所周知的“局域网”。</p><p>防火墙采用技术手段主要有如下几种：</p><ol><li><p><strong>DNS污染/劫持</strong></p><p> 我们都知道在互联网中访问一个站点前，会先通过 DNS 解析将域名解析成对应的 IP，然后才能通过 IP 进行 HTTP 访问。而 DNS 劫持即在 DNS 解析阶段动手脚。由于 DNS 协议是基于 UDP 的协议，该协议具有无状态、不可靠传输的特点，因此只要是先收到了响应就会抛弃之后的响应。</p><p> GFW 就利用了这个特性。它会在主要的 DNS 流量出口进行检测，若发现黑名单域名，就会伪装成域名服务器向客户端发回虚假回应，导致客户端请求到虚假的 IP。</p></li><li><p><strong>IP封锁</strong><br> 客户端在解析得到 IP 后，向服务端请求的过程中会经过一系列路由的转发，在路由器转发的过程中会根据路由表中存储的表项来决定下一跳的路由器或主机，选择的下一跳地址会根据路由协议来决定。</p><p> 早期使用的是ACL（访问控制列表）来进行IP黑名单限制，现在更高效的路由扩散技术来进行对特定的IP进行封锁。</p><p> 早期路由器都是采用静态路由协议，每一条路由需要进行人工来配置路由表项，或者配置一些策略，在决定路由转发，这时可以通过检测，对相应要封锁的IP配置一条错误的路由，将之牵引到一个不做任何操作的服务器（黑洞服务器），此服务器所要做的就是丢包，这样便无声息封锁掉了。动态路由协议的出现可以更高效的进行屏蔽，动态路由协议可以让路由器通过交换路由表信息来动态更新路由表，并通过寻址算法来决定最优化的路径。因此可以通过动态路由协议的路由重分发功能将错误的信息散播到整个网络，从而达到屏蔽目的。</p></li><li><p><strong>IP端口黑名单</strong><br> 该手段可以结合上边提到的IP封锁技术，将封锁精确到具体的端口，使该IP的具体端口接收不到请求，从而达到更细粒度的封锁。经常被封锁的端口如下：</p><ol><li>SSH的TCP协议22端口</li><li>HTTP的80端口</li><li>PPTP类型VPN使用的TCP协议1723端口，L2TP类型VPN使用的UDP协议1701端口，IPSec类型VPN使用的UDP协议500端口和4500端口，OpenVPN默认使用的TCP协议和UDP协议的1194端口</li><li>TLS/SSL/HTTPS的TCP协议443端口</li><li>Squid Cache的TCP协议3128端口</li></ol></li><li><p><strong>无状态TCP连接重置</strong></p><p> <img src="https://markey-oss1.oss-cn-beijing.aliyuncs.com/20170605110405666.png" alt="TCP三次握手"></p><p> TCP连接会有三次握手，此种攻击方式利用了该特点来进行攻击，gfw会对特定IP的所有数据包进行监控，会对特定黑名单动作进行监控（如TLS加密连接），当进行TCP连接时，会在TCP连接的第二部SYNC-ACK阶段，伪装成客户端和服务器同时向真实的客户端和服务器发送RESET重置，以很低的成本来达到切断双方连接的目的。与丢弃客户机的包相比，在丢包后客户机会不断的发起重试，这样会加重黑洞服务器的负担，利用TCP连接重置来断开连接，客户机也不必发送ACK来确认，这样成本就要低得多。</p></li><li><p><strong>TCP协议关键字阻断</strong><br> 该手段在无状态TCP连接重置手段之上，加入了关键字过滤功能，当协议的头部包含特定的关键字便对其连接进行重置，比如HTTP协议、ED2K协议等等。</p></li><li><p><strong>深度包检测</strong><br> 深度数据包检测（Deep packet inspection,DPI）是一种于应用层对网络上传递的数据进行侦测与处理的技术，被广泛用于入侵检测、流量分析及数据挖掘。就字面意思考虑，所谓“深度”是相对于普通的报文检测而言的——相较普通的报文检测，DPI可对报文内容和协议特征进行检测。<br>基于必要的硬件设施、适宜的检测模型及相应的模式匹配算法，gfw能够精确且快速地从实时网络环境中判别出有悖于预期标准的可疑流量，并对此及时作出审查者所期望的应对措施。</p></li></ol><hr><h2 id="Socks5协议"><a href="#Socks5协议" class="headerlink" title="Socks5协议"></a>Socks5协议</h2><p>Socks5协议是一种应用层的代理协议，在OSI七层模型中位于会话层</p><p>与Socks4相比，它多出了如下几点特性：</p><ul><li>比Socks4更加安全，增加了用户鉴权</li><li>支持UDP协议</li><li>地址方面支持域名及IPV6</li><li>SOCKS工作在比HTTP代理更低的层级</li><li>工作方式更加透明，不会重写或解释报头</li></ul><h3 id="Socks5工作原理"><a href="#Socks5工作原理" class="headerlink" title="Socks5工作原理"></a>Socks5工作原理</h3><p>参考<a href="https://tools.ietf.org/pdf/rfc1928.pdf" target="_blank" rel="noopener">论文</a></p><p>我们都知道计算机网络模型常用的有如下两种，理解了它们，有助于我们理解 Socks5 的工作原理：</p><p><img src="https://markey-oss1.oss-cn-beijing.aliyuncs.com/2018032308230858.png" alt="网络模型"></p><p>TCP/IP 模型的应用层对应 OSI 模型的前三层，链路层对应 OSI 的最后两层。计算机在网络中进行通信的时候，请求方、服务方都会有一个数据封装、解封的过程，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">          请求方                                   接收方</span><br><span class="line">应用层      --&gt;      data                data       --&gt;         应用层</span><br><span class="line">  |                   |                   ∧                      ∧</span><br><span class="line">  ∨                   ∨                   |                      |</span><br><span class="line">传输层      --&gt;     segment             segment     --&gt;         传输层</span><br><span class="line">  |                   |                   ∧                      ∧</span><br><span class="line">  ∨                   ∨                   |                      |</span><br><span class="line">网络层      --&gt;     package             package     --&gt;         网络层</span><br><span class="line">  |                   |                   ∧                      ∧</span><br><span class="line">  ∨                   ∨                   |                      |</span><br><span class="line">链路层      --&gt;      frame   &gt;&gt;传输&gt;&gt;    frame       --&gt;        链路层</span><br></pre></td></tr></table></figure><p>流程大概是应用层要发起一个请求会先将要传输的数据及协议（即 data）传递给传输层，传输层收到后，会将数据分片（segment），并加上 TCP/UDP 的协议头，之后在进入网络层时再将传输层的分片加上 IP 头，最后进入链路层加上帧头和帧尾完成数据的封装，开始传递。</p><p>在接收端则是完全相反的一套流程，就不再赘述。</p><p>而 Socks5 则是属于 TCP/IP 模型中应用层协议，用 Socks5 请求的流程大概如下：</p><ol><li>在应用层先将数据添加 Socks5 头部，发送给传输层</li><li>传输层将 Socks5 协议数据分片，添加 TCP/UDP 头部分发给网络层</li><li>网络层将 TCP/UDP 协议数据添加 IP 协议头，发往链路层</li><li>链路层添加帧头与尾，将数据封装成帧发往接收方</li></ol><h3 id="基于TCP的Socks5"><a href="#基于TCP的Socks5" class="headerlink" title="基于TCP的Socks5"></a>基于TCP的Socks5</h3><blockquote><p>参考<a href="https://zh.wikipedia.org/zh-hans/SOCKS#SOCKS5" target="_blank" rel="noopener">维基百科</a></p></blockquote><p><strong>Socks5协商</strong>：即客户端与服务端确认验证方式的一次交互。</p><p>先由客户端发起第一次握手，进行版本、方法的选择：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+----------+----------+</span><br><span class="line">|VER | NMETHODS | METHODS  |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| 1  |    1     | 1 to 255 |</span><br><span class="line">+----+----------+----------+</span><br></pre></td></tr></table></figure><ul><li>VER是SOCKS版本，这里应该是0x05；</li><li>NMETHODS是METHODS部分的长度；</li><li>METHODS是客户端支持的认证方式列表，每个方法占1字节。当前的定义是：<ul><li>0x00 不需要认证</li><li>0x01 GSSAPI</li><li>0x02 用户名、密码认证</li><li>0x03 - 0x7F由IANA分配（保留）</li><li>0x80 - 0xFE为私人方法保留</li><li>0xFF 无可接受的方法</li></ul></li></ul><p>服务端应当在客户端提供的方法中选择一个，并返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+---------+</span><br><span class="line">|VER | METHODS |</span><br><span class="line">+----+---------+</span><br><span class="line">| 1  |    1    |</span><br><span class="line">+----+---------+</span><br></pre></td></tr></table></figure><p>认证结束后，客户端就可以继续发起对请求信息的握手，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-----+-------+------+----------+----------+</span><br><span class="line">|VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |</span><br><span class="line">+----+-----+-------+------+----------+----------+</span><br><span class="line">| 1  |  1  | 0x00  |  1   | Variable |    2     |</span><br><span class="line">+----+-----+-------+------+----------+----------+</span><br></pre></td></tr></table></figure><ul><li>VER是SOCKS版本，这里应该是0x05；</li><li>CMD是SOCK的命令码<ul><li>0x01表示CONNECT请求</li><li>0x02表示BIND请求，指双向连接，比如FTP协议，一个连接用于发送命令指令，另外一个连接用于传输数据</li><li>0x03表示UDP转发</li></ul></li><li>RSV 0x00，保留</li><li>ATYP DST.ADDR类型<ul><li>0x01 IPv4地址，DST.ADDR部分4字节长度</li><li>0x03 域名，DST.ADDR部分第一个字节为域名长度，DST.ADDR剩余的内容为域名，没有\0结尾</li><li>0x04 IPv6地址，16个字节长度</li></ul></li><li>DST.ADDR 目的地址</li><li>DST.PORT 网络字节序表示的目的端口</li></ul><p>服务端收到后，应当返回对应的应答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-----+-------+------+----------+----------+</span><br><span class="line">|VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |</span><br><span class="line">+----+-----+-------+------+----------+----------+</span><br><span class="line">| 1  |  1  | 0x00  |  1   | Variable |    2     |</span><br><span class="line">+----+-----+-------+------+----------+----------+</span><br></pre></td></tr></table></figure><ul><li>VER是SOCKS版本，这里应该是0x05；</li><li>REP应答字段<ul><li>0x00表示成功</li><li>0x01普通SOCKS服务器连接失败</li><li>0x02现有规则不允许连接</li><li>0x03网络不可达</li><li>0x04主机不可达</li><li>0x05连接被拒</li><li>0x06TTL超时</li><li>0x07不支持的命令</li><li>0x08不支持的地址类型</li><li>0x09 - 0xFF未定义</li></ul></li><li>RSV 0x00，保留</li><li>ATYP BND.ADDR类型<ul><li>0x01 IPv4地址，DST.ADDR部分4字节长度</li><li>0x03域名，DST.ADDR部分第一个字节为域名长度，DST.ADDR剩余的内容为域名，没有\0结尾</li><li>0x04 IPv6地址，16个字节长度</li></ul></li><li>BND.ADDR 服务器绑定的地址</li><li>BND.PORT 网络字节序表示的服务器绑定的端口</li></ul><p>在方法、请求握手完成后，还可以进行用户名、密码认证，此处就不在赘述，可上<a href="https://zh.wikipedia.org/zh-hans/SOCKS#SOCKS5" target="_blank" rel="noopener">维基百科</a>中查阅。</p><hr><h2 id="Shadowsocks工作原理"><a href="#Shadowsocks工作原理" class="headerlink" title="Shadowsocks工作原理"></a>Shadowsocks工作原理</h2><blockquote><p>终于说到Shadowsocks工作原理了</p></blockquote><p>Shadowsocks的工作方式与普通的Socks5代理的不同之处在于，它是一个客户端-服务端模型，而普通的Socks5代理则是只有一个Socks代理服务器，如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socks5客户端  &lt;---Socks5---&gt;   Socks5服务器  &lt;---正常请求---&gt;  目标主机</span><br></pre></td></tr></table></figure><blockquote><p>Socks 5客户端在与Socks 5服务器交互的整个过程是有可能暴露在整个互联网中的，因此很容易被监控到，根据协议特征也可以很容易识别出来，若采取普通的Socks 5代理方式的话，若用于翻墙去看外边的世界，这种方式很容易被墙，代理服务器的IP极容易被加入黑名单，也就导致此代理的寿终正寝，因此一种新的方式Shadowsocks出现了。</p></blockquote><p>而Shadowsocks则处理的更加巧妙，为了防止与代理服务器的交互过程暴露，需要在本地起一个Socks5服务，让客户端发起的请求都与本地Socks5服务进行交互，再经过数据加密，传输到代理服务器上去，代理服务器也通过Socks5协议进行解析，并向目标服务器发起请求。流程大致如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Socks5客户端  &lt;---Socks5---&gt;   sslocal  </span><br><span class="line">                                   ∧</span><br><span class="line">                                   |</span><br><span class="line">                                  密文</span><br><span class="line">                                   |</span><br><span class="line">                                   ∨</span><br><span class="line">                                 ssserver  &lt;---正常请求---&gt;  目标主机</span><br></pre></td></tr></table></figure><p>其他方面基本都一样，主要的不同之处在于Shadowsocks将Socks5服务端拆解成两部分：</p><ul><li><p><strong>本地Socks5服务</strong>：用于监听客户端发起的请求，对于客户端来说是完全透明的，就相当于Socks5服务器</p></li><li><p><strong>远程Socks5服务</strong>：用于监听本地发起的Socks5请求，解析请求、发送给目标服务器，并将相应返回给本地Socks5服务</p></li><li><p><strong>本地 - 远程</strong>：本地与远程的交互过程都是加密后进行的。本地将Socks5请求准备好后，先加密发送给远程Socks5服务，远程收到后也先进行解密再进行代理，之后将收到的响应数据包加密返回给本地</p></li></ul><hr><h2 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h2><p>Shadowsocks 原版是 python 写的，之后又不断涌现了 C++、GO 等多个版本，由于本人只对 js 比较熟悉，因此以 <a href="https://www.npmjs.com/package/shadowsocks-js" target="_blank" rel="noopener">shadowsocks-js</a> 为例</p><blockquote><p>官方的 <a href="https://github.com/shadowsocks/shadowsocks-nodejs" target="_blank" rel="noopener">shadowsocks-nodejs</a> 由于 nodejs 的内存占用问题，已经停止维护了，没有以它为例，本例可以说是它的一个替代方案。</p></blockquote><p>主要功能代码都在 lib 目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   ├── localssjs // 本地服务启动命令</span><br><span class="line">│   └── serverssjs // 远程服务启动命令</span><br><span class="line">├── config.json // ss配置</span><br><span class="line">├── lib</span><br><span class="line">│   ├── auth.js // Socks5用户校验相关方法</span><br><span class="line">│   ├── cli.js // 命令行启动工具</span><br><span class="line">│   ├── createUDPRelay.js // UDP代理相关</span><br><span class="line">│   ├── daemon.js // 守护进程相关</span><br><span class="line">│   ├── defaultConfig.js // 默认ss配置</span><br><span class="line">│   ├── encryptor.js // 加密、解密相关方法</span><br><span class="line">│   ├── filter.js</span><br><span class="line">│   ├── gfwlistUtils.js // 防火墙相关方法，用于PAC切换</span><br><span class="line">│   ├── logger.js</span><br><span class="line">│   ├── pacServer.js // PAC服务</span><br><span class="line">│   ├── pid.js</span><br><span class="line">│   ├── recordMemoryUsage.js // 内存记录</span><br><span class="line">│   ├── ssLocal.js // 本地Socks5服务</span><br><span class="line">│   ├── ssServer.js // 远程Socks5服务</span><br><span class="line">│   └── utils.js</span><br><span class="line">├── logs</span><br><span class="line">│   ├── local.log</span><br><span class="line">│   └── server.log</span><br><span class="line">├── node_modules</span><br><span class="line">├── pac</span><br><span class="line">│   ├── gfwlist.txt</span><br><span class="line">│   └── user.txt</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br><span class="line">├── test</span><br><span class="line">└── vendor</span><br></pre></td></tr></table></figure><p>核心代码就只有 ssLocal.js、ssServer.js，下面会分别讲解其作用</p><p>ssLocal.js 只有400多行，还算比较容易看懂，其核心方法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理 method 握手</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleMethod</span>(<span class="params">connection, data, authInfo</span>) </span>&#123;</span><br><span class="line">  ...处理 method 握手响应头部</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回响应</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  connection.write(buf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> method === <span class="number">0</span> ? <span class="number">1</span> : <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchUsernamePassword</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  ...获取用户名及密码，用于Socks5身份校验</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">responseAuth</span>(<span class="params">success, connection</span>) </span>&#123;</span><br><span class="line">  ...响应身份校验</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usernamePasswordAuthetication</span>(<span class="params">connection, data, authInfo</span>) </span>&#123;</span><br><span class="line">  ...调用上述两方法，处理身份校验</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理 request 握手，并链接远程Socks5服务器，添加事件监听</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRequest</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    connection, data, _ref, </span></span></span><br><span class="line"><span class="function"><span class="params">    dstInfo, onConnect, onDestroy,</span></span></span><br><span class="line"><span class="function"><span class="params">    isClientConnected</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  ...准备响应数据</span><br><span class="line">  <span class="keyword">if</span> (isUDPRelay) &#123;</span><br><span class="line">    ...单独针对UDP请求处理</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将客户端发送的数据进行加密，用于之后传输给远程服务器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  tmp = (<span class="number">0</span>, _encryptor.createCipher)(password, method, data.slice(<span class="number">3</span>)); <span class="comment">// skip VER, CMD, RSV</span></span><br><span class="line">  cipher = tmp.cipher;</span><br><span class="line">  cipheredData = tmp.data;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 连接远程服务器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">var</span> clientToRemote = (<span class="number">0</span>, _net.connect)(clientOptions, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    logger.warn(<span class="string">'Local server has connected remote server.'</span>);</span><br><span class="line">    onConnect();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 收到远程服务器的响应后，先解密再传递给客户端</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  clientToRemote.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">remoteData</span>) </span>&#123;</span><br><span class="line">    ...对远程服务器返回的数据解密，并返回给客户端</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 完成 request 握手</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  connection.write(repBuf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理客户端与本地服务的链接，判断不同的阶段分别进行处理</span></span><br><span class="line"><span class="comment"> *  0：method握手阶段</span></span><br><span class="line"><span class="comment"> *  1：request握手阶段</span></span><br><span class="line"><span class="comment"> *  2：数据传输阶段</span></span><br><span class="line"><span class="comment"> *  3：Socks5用户校验阶段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleConnection</span>(<span class="params">config, connection</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 处理来自客户端的请求，不同阶段根据不同方式处理</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  connection.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (stage) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: ...处理method握手</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: ...处理request握手</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: ...将数据传输给远程服务</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>: ...处理用户校验</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createServer</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  ...启动本地服务，添加事件监听</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ssServer.js 代码相对来说更简单，只有不到300行，核心方法只有三个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链接目标服务器，并将响应的数据加密返回给本地</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClientToDst</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    connection, data, password,</span></span></span><br><span class="line"><span class="function"><span class="params">    method, onConnect, onDestroy,</span></span></span><br><span class="line"><span class="function"><span class="params">    isLocalConnected</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 链接目标服务器</span></span><br><span class="line">  <span class="keyword">var</span> clientToDst = (<span class="number">0</span>, _net.connect)(clientOptions, onConnect);</span><br><span class="line"></span><br><span class="line">  clientToDst.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">clientData</span>) </span>&#123;</span><br><span class="line">    ...对目标服务器的响应加密，再返回本地服务</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理本地服务发起的请求，根据不同阶段分别处理</span></span><br><span class="line"><span class="comment"> *  0：未连接目标服务器</span></span><br><span class="line"><span class="comment"> *  1：已连接目标服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleConnection</span>(<span class="params">config, connection</span>) </span>&#123;</span><br><span class="line">  connection.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunck</span>) </span>&#123;</span><br><span class="line">    ...解密本地服务的数据</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (stage) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: ...调用上一个方法链接目标服务器</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: ...将本地服务的请求数据发送给目标服务器</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动远程服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createServer</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  ...启动远程服务，添加事件监听</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Shadowsocks翻墙原理探究&quot;&gt;&lt;a href=&quot;#Shadowsocks翻墙原理探究&quot; class=&quot;headerlink&quot; title=&quot;Shadowsocks翻墙原理探究&quot;&gt;&lt;/a&gt;Shadowsocks翻墙原理探究&lt;/h1&gt;&lt;p&gt;Shadowsock
      
    
    </summary>
    
    
      <category term="coding" scheme="https://blog.markeyme.cn/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>ES6异步方式全面解析</title>
    <link href="https://blog.markeyme.cn/2018/06/09/ES6%E5%BC%82%E6%AD%A5%E6%96%B9%E5%BC%8F%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/"/>
    <id>https://blog.markeyme.cn/2018/06/09/ES6异步方式全面解析/</id>
    <published>2018-06-09T03:25:30.000Z</published>
    <updated>2018-06-10T15:46:14.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6异步方式全面解析"><a href="#ES6异步方式全面解析" class="headerlink" title="ES6异步方式全面解析"></a>ES6异步方式全面解析</h1><p>众所周知JS是单线程的，这种设计让JS避免了多线程的各种问题，但同时也让JS同一时刻只能执行一个任务，若这个任务执行时间很长的话（如死循环），会导致JS直接卡死，在浏览器中的表现就是页面无响应，用户体验非常之差。</p><p>因此，在JS中有两种任务执行模式：<strong>同步（Synchronous）和异步（Asynchronous）</strong>。类似函数调用、流程控制语句、表达式计算等就是以同步方式运行的，而异步主要由<code>setTimeout/setInterval</code>、事件实现。</p><hr><h3 id="传统的异步实现"><a href="#传统的异步实现" class="headerlink" title="传统的异步实现"></a>传统的异步实现</h3><p>作为一个前端开发者，无论是浏览器端还是Node，相信大家都使用过事件吧，通过事件肯定就能想到<strong>回调函数</strong>，它就是实现异步最常用、最传统的方式。</p><p>不过要注意，不要以为回调函数就都是异步的，如ES5的数组方法<code>Array.prototype.forEach((ele) =&gt; {})</code>等等，它们也是同步执行的。回调函数只是一种处理异步的方式，属于函数式编程中<strong>高阶函数</strong>的一种，并不只在处理异步问题中使用。</p><p>举个栗子🌰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最常见的ajax回调</span></span><br><span class="line"><span class="keyword">this</span>.ajax(<span class="string">'/path/to/api'</span>, &#123;</span><br><span class="line">    params: params</span><br><span class="line">&#125;, (res) =&gt; &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你可能觉得这样并没有什么不妥，但是若有多个ajax或者异步操作需要依次完成呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.ajax(<span class="string">'/path/to/api'</span>, &#123;</span><br><span class="line">    params: params</span><br><span class="line">&#125;, (res) =&gt; &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">    <span class="keyword">this</span>.ajax(<span class="string">'/path/to/api'</span>, &#123;</span><br><span class="line">      params: params</span><br><span class="line">    &#125;, (res) =&gt; &#123;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">        <span class="keyword">this</span>.ajax(<span class="string">'/path/to/api'</span>, &#123;</span><br><span class="line">          params: params</span><br><span class="line">        &#125;, (res) =&gt; &#123;</span><br><span class="line">          <span class="comment">// do something...</span></span><br><span class="line">        &#125;)</span><br><span class="line">        ...</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>回调地狱就出现了。。。😢</p><p>为了解决这个问题，社区中提出了<strong>Promise</strong>方案，并且该方案在ES6中被标准化，如今已广泛使用。</p><hr><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>使用Promise的好处就是让开发者远离了回调地狱的困扰，它具有如下特点：</p><ol><li><p>对象的状态不受外界影响：</p><ul><li>Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。</li><li>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li></ul></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。</p><ul><li>Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。</li><li>只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。</li><li>如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。</li><li>这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li></ul></li><li><p>一旦声明Promise对象（new Promise或Promise.resolve等），就会立即执行它的函数参数，若不是函数参数则不会执行</p></li></ol><p>上面的代码可以改写成如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.ajax(<span class="string">'/path/to/api'</span>, &#123;</span><br><span class="line">    params: params</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.ajax(<span class="string">'/path/to/api'</span>, &#123;</span><br><span class="line">        params: params</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.ajax(<span class="string">'/path/to/api'</span>, &#123;</span><br><span class="line">        params: params</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>看起来就直观多了，就像一个链条一样将多个操作依次串了起来，再也不用担心回调了~😄</p><p>同时Promise还有许多其他API，如<code>Promise.all</code>、<code>Promise.race</code>、<code>Promise.resolve/reject</code>等等（可以参考<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">阮老师的文章</a>），在需要的时候配合使用都是极好的。</p><p>API无需多说，不过这里我总结了一下自己之前使用Promise踩到的坑以及我对Promise理解不够透彻的地方，希望也能帮助大家更好地使用Promise：</p><ol><li><p><strong>then的返回结果</strong>：</p><ul><li>如果<code>then</code>方法中返回了一个值，那么返回一个“新的”resolved的Promise，并且resolve回调函数的参数值是这个值</li><li>如果<code>then</code>方法中抛出了一个异常，那么返回一个“新的”rejected状态的Promise</li><li>如果<code>then</code>方法返回了一个未知状态（pending）的Promise新实例，那么返回的新Promise就是未知状态</li><li><p>如果<code>then</code>方法没有返回值时，那么会返回一个“新的”resolved的Promise，但resolve回调函数没有参数</p><p>我之前天真的以为<code>then</code>要想链式调用，必须要手动返回一个新的Promise才行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'first promise'</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// return Promise.resolve('next promise')</span></span><br><span class="line">    <span class="comment">// 实际上两种返回是一样的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'next promise'</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>一个Promise可设置多个then回调，会按定义顺序执行</strong>，如下</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  res(<span class="string">'hahaha'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="built_in">console</span>.log)</span><br><span class="line">p.then(<span class="built_in">console</span>.warn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种方式与链式调用不要搞混，链式调用实际上是then方法返回了新的Promise，而不是原有的，可以验证一下：</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">123</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p1 === p2)</span><br><span class="line">    <span class="comment">// false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong><code>then</code>或<code>catch</code>返回的值不能是当前promise本身，否则会造成死循环</strong>：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong><code>then</code>或者<code>catch</code>的参数期望是函数，传入非函数则会发生值穿透</strong>：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="number">2</span>)</span><br><span class="line">  .then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">  .then(<span class="built_in">console</span>.log)</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>process.nextTick</code>和<code>promise.then</code>都属于microtask，而<code>setImmediate</code>、<code>setTimeout</code>属于macrotask</strong></p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line"><span class="comment">// end nextTick then setImmediate</span></span><br></pre></td></tr></table></figure><p> 有关<strong>microtask</strong>及<strong>macrotask</strong>可以看<a href="https://juejin.im/entry/58d4df3b5c497d0057eb99ff" target="_blank" rel="noopener">这篇文章</a>，讲得很细致。</p></li></ol><p>但Promise也存在弊端，那就是若步骤很多的话，需要写一大串<code>.then()</code>，尽管步骤清晰，但是对于我们这些追求极致优雅的前端开发者来说，代码全都是Promise的API（<code>then</code>、<code>catch</code>），操作的语义太抽象，还是让人不够满意呀~</p><hr><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>Generator是ES6规范中对协程的实现，但目前大多被用于异步模拟同步上了。</p><p>执行它会返回一个<a href="http://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="noopener">遍历器对象</a>，而每次调用<code>next</code>方法则将函数执行到下一个<code>yield</code>的位置，若没有则执行到return或末尾。</p><p>依旧是不再赘述API，对它还不了解的可以查阅<a href="http://es6.ruanyifeng.com/#docs/generator#%E7%AE%80%E4%BB%8B" target="_blank" rel="noopener">阮老师的文章</a>。</p><p>通过Generator实现异步：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> res = <span class="keyword">yield</span> getData()</span><br><span class="line">   <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       it.next(&#123;</span><br><span class="line">           name: <span class="string">'yuanye'</span>,</span><br><span class="line">           age: <span class="number">22</span></span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> it = main()</span><br><span class="line">it.next()</span><br></pre></td></tr></table></figure><p>先不管下面的<code>next</code>方法，单看<code>main</code>方法中，<code>getData</code>模拟的异步操作已经看起来很像同步了。但是追求完美的我们肯定是无法忍受每次还要手动调用<code>next</code>方法来继续执行流程的，为此<a href="https://github.com/tj" target="_blank" rel="noopener">TJ大神</a>为社区贡献了<a href="https://github.com/tj/co" target="_blank" rel="noopener">co模块</a>来自动化执行Generator，它的实现原理非常巧妙，源码只有短短的200多行，感兴趣可以去研究下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>)</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res1 = <span class="keyword">yield</span> [<span class="string">'step-1'</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(res1)</span><br><span class="line">  <span class="comment">// 若yield后面返回的是promise，则会等待它resolved后继续执行之后的流程</span></span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      res(<span class="string">'step-2'</span>)</span><br><span class="line">    &#125;, <span class="number">2500</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(res2)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'end'</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end: '</span> + data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样就让异步的流程完全以同步的方式展示出来啦😋~</p><hr><h3 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h3><p>ES7标准中引入的async函数，是对js异步解决方案的进一步完善，它有如下特点：</p><ol><li><strong>内置执行器</strong>：不用像generator那样反复调用next方法，或者使用<strong>co模块</strong>，调用即会自动执行，并返回结果</li><li><strong>返回Promise</strong>：generator返回的是iterator对象，因此还不能直接用<code>then</code>来指定回调</li><li><strong>await更友好</strong>：相比<strong>co模块</strong>约定的generator的yield后面只能跟promise或thunk函数或者对象及数组，await后面既可以是promise也可以是任意类型的值（Object、Number、Array，甚至Error等等，不过此时等同于同步操作）</li></ol><p>进一步说，<strong>async函数完全可以看作多个异步操作，包装成的一个Promise对象，而await命令就是内部then命令的语法糖</strong>。</p><p>改写后代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res1 = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      res(<span class="string">'step-1'</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(res1)</span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'step-2'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res2)</span><br><span class="line">  <span class="keyword">const</span> res3 = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      res(<span class="string">'step-3'</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(res3)</span><br><span class="line">  <span class="keyword">return</span> [res1, res2, res3, <span class="string">'end'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testAsync().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样不仅语义还是流程都非常清晰，即便是不熟悉业务的开发者也能一眼看出哪里是异步操作。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文汇总了当前主流的JS异步解决方案，其实没有哪一种方法最好或不好，都是在不同的场景下能发挥出不同的优势。而且目前都是Promise与其他两个方案配合使用的，所以不存在你只学会async/await或者generator就可以玩转异步。没准以后又会出现一个新的方案，将已有的这几种方案颠覆呢 ~ </p><p>在这不断变化、发展的时代，我们前端要放开自己的眼界，拥抱变化，持续学习，才能成长，写出优质的代码😜~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6异步方式全面解析&quot;&gt;&lt;a href=&quot;#ES6异步方式全面解析&quot; class=&quot;headerlink&quot; title=&quot;ES6异步方式全面解析&quot;&gt;&lt;/a&gt;ES6异步方式全面解析&lt;/h1&gt;&lt;p&gt;众所周知JS是单线程的，这种设计让JS避免了多线程的各种问题，但同时
      
    
    </summary>
    
    
      <category term="coding" scheme="https://blog.markeyme.cn/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>工程师的一些职场认知</title>
    <link href="https://blog.markeyme.cn/2018/03/25/%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%81%8C%E5%9C%BA%E8%AE%A4%E7%9F%A5/"/>
    <id>https://blog.markeyme.cn/2018/03/25/工程师的职场认知/</id>
    <published>2018-03-25T01:27:16.000Z</published>
    <updated>2018-03-25T01:27:49.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工程师的一些职场认知"><a href="#工程师的一些职场认知" class="headerlink" title="工程师的一些职场认知"></a>工程师的一些职场认知</h1><p>从<a href="https://www.baidufe.com" target="_blank" rel="noopener">Alien</a>博客看到的，觉得很有道理。内容比较多，没办法一次都做到，先mark下来，一步步来吧，希望能够尽快都做到😄~</p><p><img src="https://markey-oss1.oss-cn-beijing.aliyuncs.com/%E8%81%8C%E5%9C%BA%E8%AE%A4%E7%9F%A5.png" alt="工程师的职场认知"></p><blockquote><p><a href="https://www.baidufe.com/item/8de42948e042fb0d0da2.html" target="_blank" rel="noopener">原文链接</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工程师的一些职场认知&quot;&gt;&lt;a href=&quot;#工程师的一些职场认知&quot; class=&quot;headerlink&quot; title=&quot;工程师的一些职场认知&quot;&gt;&lt;/a&gt;工程师的一些职场认知&lt;/h1&gt;&lt;p&gt;从&lt;a href=&quot;https://www.baidufe.com&quot; tar
      
    
    </summary>
    
    
      <category term="profession" scheme="https://blog.markeyme.cn/tags/profession/"/>
    
  </entry>
  
  <entry>
    <title>Jimp node-qrcode生成图片并上传总结</title>
    <link href="https://blog.markeyme.cn/2018/03/20/Jimp%20node-qrcode%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E5%B9%B6%E4%B8%8A%E4%BC%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.markeyme.cn/2018/03/20/Jimp node-qrcode生成图片并上传总结/</id>
    <published>2018-03-20T12:01:29.000Z</published>
    <updated>2018-03-21T01:46:10.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node图片处理——Jimp配合node-qrcode生成图片上传总结"><a href="#Node图片处理——Jimp配合node-qrcode生成图片上传总结" class="headerlink" title="Node图片处理——Jimp配合node-qrcode生成图片上传总结"></a>Node图片处理——Jimp配合node-qrcode生成图片上传总结</h1><p>上周产品那边来了一个需求，需要基于原图针对不同用户生成不同二维码以及文案，并生成新图片，让用户能够保存。接到这个需求时，心里不仅没有拒绝的意思，反而有点小兴奋 ~ 因为又能探索一下新东西。</p><p>大致效果如下，原图：</p><p><img style="height: 400px;" src="https://markey-oss1.oss-cn-beijing.aliyuncs.com/bg_invite.png"></p><p>效果图：</p><p><img style="height: 400px;" src="https://markey-oss1.oss-cn-beijing.aliyuncs.com/result.jpg"></p><h3 id="试水canvas"><a href="#试水canvas" class="headerlink" title="试水canvas"></a>试水canvas</h3><p>刚开始打算在前端用canvas生成图片。我们都知道canvas有合成图片的功能，核心是<code>drawImage</code>及<code>toDataURL</code>这两个方法。</p><p>大致思路是：</p><ol><li>使用<code>drawImage</code>将生成的二维码合并到原图的指定位置</li><li>使用<code>fillText</code>方法生成文案</li><li>用<code>toDataURL</code>将图片转成base64</li><li>使用 atob 以及 Uint8Array 将其转为Buffer进行上传。</li></ol><p>不过最终该方案没有走通，因为不同手机尺寸比例不统一，生成的二维码的位置无法准确地定位到指定位置，因此采用了另一种方案：node层生成图片。</p><h3 id="node搞起"><a href="#node搞起" class="headerlink" title="node搞起"></a>node搞起</h3><p>在node层就无需考虑适配的问题了，因为只有一个基准，也就是原图。生成二维码及文案的尺寸、位置都可以直接写死。经过调研，node图像处理库最出名的有两个，分别是：<a href="https://github.com/oliver-moran/jimp" target="_blank" rel="noopener">Jimp</a> 和 <a href="https://github.com/lovell/sharp" target="_blank" rel="noopener">Sharp</a>，最终选用Jimp，因为Sharp没安装上😓。二维码库倒是很多，最终决定选用 <a href="https://github.com/soldair/node-qrcode" target="_blank" rel="noopener">node-qrcode</a>。</p><p>开搞！</p><p>主要步骤就两步，如下：</p><ol><li>生成图片</li><li>读取图片并上传</li></ol><p>下面分解这两步讲解</p><h4 id="生成图片"><a href="#生成图片" class="headerlink" title="生成图片"></a>生成图片</h4><p>生成图片是最麻烦的。步骤比较多：</p><ol><li>使用qrcode生成二维码 Buffer</li><li>包装二维码Buffer为Jimp对象</li><li>生成文案</li><li>合成图片并保存</li></ol><p>大部分都是调用Jimp及qrcode的api，还有一些node的原生api，如使用<code>Buffer.from</code>将base64转为Buffer。感兴趣的可以去参阅它们的文档：</p><ul><li><a href="https://github.com/oliver-moran/jimp" target="_blank" rel="noopener">Jimp</a></li><li><a href="https://github.com/soldair/node-qrcode" target="_blank" rel="noopener">node-qrcode</a></li><li><a href="http://nodejs.cn/api/buffer.html#buffer_class_method_buffer_from_string_encoding" target="_blank" rel="noopener">Node Buffer</a></li></ul><p>由于生成图片步骤较多，每一步都依赖上一步的结果，并且都是异步的，如果使用回调的话就彻底陷入回调地狱了😓，因此主要想说的是代码组织方式。不怕大家笑话，我的第一版代码是这样的🤣：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成二维码Buffer</span></span><br><span class="line"><span class="keyword">const</span> codeBuffer = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  Qrcode.toDataURL(url, &#123;&#125;, (err, url) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 注意：这里必须把“data:image/png;base64,”这一段去掉才能转成正确的buffer</span></span><br><span class="line">    <span class="keyword">const</span> res = Buffer.from(url.replace(<span class="regexp">/.+,/</span>, <span class="string">''</span>), <span class="string">'base64'</span>)</span><br><span class="line">    err ? reject(err) : resolve(res)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 生成文字</span></span><br><span class="line"><span class="keyword">const</span> textJimp = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> Jimp(textBgWidth, config.textBgHeight, +<span class="string">`0xFF<span class="subst">$&#123;config.textBgColor&#125;</span>`</span>, (err, image) =&gt; &#123;</span><br><span class="line">    Jimp.loadFont(config.fontPath).then(<span class="function">(<span class="params">font</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(image.print(font, config.textPadding, <span class="number">10</span>, textContent, <span class="number">10</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 将二维码Buffer包装成Jimp对象</span></span><br><span class="line"><span class="keyword">const</span> codeJimp = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  Jimp.read(codeBuffer).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">      resolve(res.resize(config.codeWidth, config.codeWidth))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      reject(<span class="string">'包装buffer失败'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  Jimp.read(config.originImgPath).then(<span class="function"><span class="params">img</span> =&gt;</span> &#123;</span><br><span class="line">    img.composite(codeJimp, config.codeLeft, config.codeTop)</span><br><span class="line">       .composite(textJimp, config.textLeft, config.textTop)</span><br><span class="line">       <span class="comment">// 由于fs.createReadStream不能接受Buffer作为参数，只能将生成的图片临时保存到本地</span></span><br><span class="line">       .write(config.tempFilePath, () =&gt; &#123;</span><br><span class="line">         <span class="comment">// resolve()</span></span><br><span class="line">         reject(<span class="string">'保存图片失败！'</span>)</span><br><span class="line">       &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'保存图片出错：'</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为我们使用的node前后端分离框架 <a href="https://github.com/xiongwilee/Gracejs" target="_blank" rel="noopener">grace</a> 的版本是支持 generator 语法的，所以想到了使用 yield 来将异步操作同步展示，但还是看起来太繁琐了😓，必须重构！</p><p>promise 登场！</p><p>使用 promise 的链式调用语法，结构就会清晰很多，改写后代码是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合多个异步I/O</span></span><br><span class="line"><span class="keyword">const</span> imgResult = <span class="keyword">yield</span> generateCode(href)</span><br><span class="line">  <span class="comment">// 生成二维码Buffer</span></span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    codeBuffer = res;</span><br><span class="line">    <span class="comment">// 包装二维码Buffer为Jimp对象</span></span><br><span class="line">    <span class="keyword">return</span> wrapCodeBuffer(codeBuffer, imgConfig);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    codeJimp = res;</span><br><span class="line">    <span class="comment">// 生成文字</span></span><br><span class="line">    <span class="keyword">return</span> generateText(textBgWidth, textContent, imgConfig);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    textJimp = res;</span><br><span class="line">    <span class="comment">// 组合并生成图片</span></span><br><span class="line">    <span class="keyword">return</span> compositeImg(imgConfig, textJimp, codeJimp);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 成功</span></span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">true</span>)</span><br><span class="line">  <span class="comment">// 中途出错</span></span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>瞬间优雅的许多 ~<br>实现方法也很简单，就是让每个步骤的方法都返回一个 promise 即可，拿该方法为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包装二维码Buffer为Jimp对象</span></span><br><span class="line"><span class="comment"> * @param  &#123;Buffer&#125; codeBuffer  [二维码Buffer对象]</span></span><br><span class="line"><span class="comment"> * @param  &#123;Object&#125; config      [配置对象]</span></span><br><span class="line"><span class="comment"> * @return &#123;Promise&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapCodeBuffer</span>(<span class="params">codeBuffer, config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    Jimp.read(codeBuffer).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        resolve(res.resize(config.codeWidth, config.codeWidth));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">'包装二维码Buffer失败'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h4><p>接下来是使用node上传图片。由于使用的后端接口是基于FormData方式的，所以要在node层模拟一个FormData上传请求。<br>起初是完全懵逼的，因为对http协议的这块标准一直是一知半解。在前端使用FormData上传图片时我们经常能看到请求体是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">------WebKitFormBoundarywQMoN5B2ZNAD6uqN</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;avatar.jpeg&quot;</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundarywQMoN5B2ZNAD6uqN--</span><br></pre></td></tr></table></figure><p>请求头的Content-Type是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundarywQMoN5B2ZNAD6uqN</span><br></pre></td></tr></table></figure><p>看起来挺复杂的，尤其是这个<code>------WebKitFormBoundarywQMoN5B2ZNAD6uqN--</code>到底是个什么鬼😢。</p><p>别急，先从我的这个上传方法讲起：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传图片方法</span></span><br><span class="line"><span class="comment"> * @param  &#123;ClientRequest&#125; request  [由http.request方法返回的对象]</span></span><br><span class="line"><span class="comment"> * @param  &#123;Object&#125;        config   [配置对象]</span></span><br><span class="line"><span class="comment"> * @param  &#123;String&#125;        cookies  [用户请求时所带的所有cookie]</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uploadImg</span>(<span class="params">request, config, cookies = <span class="string">''</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 模拟form-data请求后端接口上传图片</span></span><br><span class="line">  <span class="keyword">const</span> boundaryKey = <span class="built_in">Math</span>.random().toString(<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">const</span> endData = <span class="string">'\r\n----'</span> + boundaryKey + <span class="string">'--'</span>;</span><br><span class="line">  <span class="keyword">let</span> contentLength = <span class="number">0</span>,</span><br><span class="line">      content = <span class="string">''</span>;</span><br><span class="line">  content += <span class="string">'\r\n----'</span> + boundaryKey + <span class="string">'\r\n'</span> +</span><br><span class="line">            <span class="string">'Content-Type: application/octet-stream\r\n'</span> +</span><br><span class="line">            <span class="string">'Content-Disposition: form-data; name="file"; '</span> +</span><br><span class="line">            <span class="string">'filename="bg_invite.png"; \r\n'</span> +</span><br><span class="line">            <span class="string">'Content-Transfer-Encoding: binary\r\n\r\n'</span>;</span><br><span class="line">  <span class="keyword">let</span> contentBinary = Buffer.from(content, <span class="string">'utf-8'</span>);</span><br><span class="line">  <span class="comment">// 获取上传内容总大小</span></span><br><span class="line">  contentLength = fs.statSync(config.tempFilePath).size + Buffer.byteLength(contentBinary) + Buffer.byteLength(endData);</span><br><span class="line">  <span class="comment">// 设置请求头</span></span><br><span class="line">  request.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'multipart/form-data; boundary=--'</span> + boundaryKey);</span><br><span class="line">  request.setHeader(<span class="string">'Content-Length'</span>, contentLength);</span><br><span class="line">  request.setHeader(<span class="string">'Cookie'</span>, cookies);</span><br><span class="line">  request.write(contentBinary);</span><br><span class="line">  <span class="keyword">const</span> fileStream = fs.createReadStream(config.tempFilePath, &#123; <span class="attr">bufferSize</span>: <span class="number">4</span> * <span class="number">1024</span> &#125;);</span><br><span class="line">  fileStream.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    request.end(endData);</span><br><span class="line">  &#125;);</span><br><span class="line">  fileStream.pipe(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个方法其实就是构造了请求，拆分下来就如下几件事：</p><ul><li>构造请求头</li><li>计算上传内容总大小</li><li>将文件以流的形式写入<a href="http://nodejs.cn/api/http.html#http_class_http_clientrequest" target="_blank" rel="noopener">http.ClientRequest</a>对象</li></ul><p>先说请求头，FormData形式的请求Content-Type为<code>multipart/form-data</code>，并且一定要提供<code>boundary</code>字段。可是为什么呢？</p><p>我们都知道默认提交表单时，Content-Type是<code>application/x-www-form-urlencoded</code>，并且参数都是已类似<code>name=John&amp;age=12</code>这种形式在请求体中传递的，参数是以<code>&amp;</code>分割的。这里的<code>boundary</code>的作用就跟<code>&amp;</code>一样，是用来分割多个参数的，并且是可以自定义的，而在浏览器中，是浏览器为我们自动生成的，这就知道了上文中那个<code>boundary</code>是怎么回事了 ~</p><p>再看每个<code>boundary</code>之间的内容，也就是每个字段，其中还有Content-type及Content-Disposition字段我们很陌生。</p><p>Content-Type跟http协议的Content-Type是一样的，只不过在<code>multipart/form-data</code>类型中，我们可以手动指定每个参数的Content-Type。方法中的字段值为<code>application/octet-stream</code>，就是告诉Server这部分内容是字节流，因为我们需要以字节流的形式上传图片。</p><p>而Content-Disposition是每个参数必须的选项，并且值必须为<code>form-data</code>。该头其实还有其他用途，可以参阅<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition" target="_blank" rel="noopener">MDN的官方文档</a>。</p><p>接下来是计算Content-Length。这里主要使用了node的<a href="http://nodejs.cn/api/fs.html" target="_blank" rel="noopener">fs模块</a>，以及<a href="http://nodejs.cn/api/buffer.html" target="_blank" rel="noopener">Buffer模块</a>的api，都很好理解，查看文档即可。</p><p>最后是将图片写入http.ClientRequest对象中。该对象是由node的http.request方法返回，并且是一个可写流。引用<a href="http://nodejs.cn/api/http.html#http_http_request_options_callback" target="_blank" rel="noopener">node官方文档</a>的话：</p><blockquote><p>ClientRequest 实例是一个可写流。 如果需要通过 POST 请求上传一个文件，则写入到 ClientRequest 对象。</p></blockquote><p>最后再调用http.ClientRequest对象的end方法，即可完成请求对象的写入，就发出请求啦 ~</p><p>至此，一个Node合成图片并上传的需求完成！过程中收获非常多！</p><p>生命不息折腾不止！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Node图片处理——Jimp配合node-qrcode生成图片上传总结&quot;&gt;&lt;a href=&quot;#Node图片处理——Jimp配合node-qrcode生成图片上传总结&quot; class=&quot;headerlink&quot; title=&quot;Node图片处理——Jimp配合node-q
      
    
    </summary>
    
    
      <category term="coding" scheme="https://blog.markeyme.cn/tags/coding/"/>
    
      <category term="node" scheme="https://blog.markeyme.cn/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>观《盲山》有感</title>
    <link href="https://blog.markeyme.cn/2018/03/03/%E8%A7%82%E3%80%8A%E7%9B%B2%E5%B1%B1%E3%80%8B%E6%9C%89%E6%84%9F/"/>
    <id>https://blog.markeyme.cn/2018/03/03/观《盲山》有感/</id>
    <published>2018-03-03T13:40:29.000Z</published>
    <updated>2018-03-05T01:45:49.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="观《盲山》有感"><a href="#观《盲山》有感" class="headerlink" title="观《盲山》有感"></a>观《盲山》有感</h1><blockquote><p>不是影评，只是观后感</p></blockquote><p>今天看了《盲山》后，心情无比压抑。虽然这部电影的故事已经耳熟能详，无论电视上还是网络中已经有过各种拐卖妇女的报道，所以从一开始就基本能想到剧情的发展方向，但是过程中依旧被种种场景震撼，比如雪梅逃出屋子后被全村的男人联合抓回，村里其他被拐卖妇女劝说雪梅她们是如何屈服的，警察来到村里营救却被村民围堵威胁导致营救失败等等。电视上对这类报道听得多了，就会有些麻木，但看了这部电影不得不赞叹导演对各种细节的精妙表述，能够切身体会到被拐妇女的绝望，不得不给给李杨导演点个赞。<br></p><h2 id="先说说让我印象最深刻的几个男人"><a href="#先说说让我印象最深刻的几个男人" class="headerlink" title="先说说让我印象最深刻的几个男人"></a>先说说让我印象最深刻的几个男人</h2><h3 id="黄德贵"><a href="#黄德贵" class="headerlink" title="黄德贵"></a>黄德贵</h3><p>无论酒桌上的这句“谁不喝完这酒，谁就一辈子打光棍，儿子孙子也打光棍，下辈子还是打光棍！”，还是被雪梅劝说时的强词夺理“坐个球的牢，哪家娶媳妇不花钱”，都能看出这个人的“盲”。在他眼里，女人就是自己的工具、仆人，结婚也不过是花一笔钱就了了的事。他不知道什么叫拐卖妇女，因为村里人都这么干；他也不知道结婚是有法律效益的，是两情相悦的，因为他“经验丰富”的父亲就是认为“女人就要收拾”。生长环境的“盲”导致了他的“盲”，并且会继续传递下去，恶性循环。也许帮雪梅寄信的刘青山长大后也娶了买来的媳妇。</p><h3 id="黄父"><a href="#黄父" class="headerlink" title="黄父"></a>黄父</h3><p>刚开始感觉这个老人看起来还是挺老实憨厚的，直到他为了帮他无能的儿子“办事”，跟黄母一块控制雪梅好让黄德贵强奸她后，彻底颠覆了对他印象。而且在德贵办完事后还赞许地给他递支烟，仿佛认可德贵的能力一样，顿时让我感觉一阵恶心。</p><h3 id="黄德诚"><a href="#黄德诚" class="headerlink" title="黄德诚"></a>黄德诚</h3><p>刚开始觉得这个人可能是雪梅的最后救星，他是全村看起来唯一有点良知的。看到后面才发现，无论是以救雪梅逃出去为名义而摸她的手，还是最后直接搞了雪梅的身子，这个人的那点学问全都用在了虚伪上。<br><br>最后事情败露，不仅让雪梅再次挨了打，之后为了逃避责任抛弃了雪梅，一个人离开了村子。雪梅逃出去最大的希望破灭。他所说的“道德的德，诚信的诚”真是对他一个天大的讽刺。<br><br>可能有人觉得雪梅是真心喜欢他，或者只是为了逃出去而利用他，无论怎样，最终受伤的依旧是雪梅。德诚走后，雪梅没有哭没有闹，只是静静地烧掉了他送的书，然后来到小卖铺跟老板做了“交易”。在经历了那么多事以后，她已经开始麻木，习惯了受伤，但唯一让我庆幸的是，她始终没有放弃抵抗。相比村里其他被拐卖来的女人，雪梅无疑是坚强的。<br><br>后来看了影评后惊了，才发现那个扮演同样被拐卖来的女人的演员就是真实被拐卖来，生活在那个村子里的，并且才20岁就已经是两个孩子的妈。</p><h2 id="其他人"><a href="#其他人" class="headerlink" title="其他人"></a>其他人</h2><p>无论是帮德贵将雪梅抓回去的男人们、眼睁睁看着雪梅的求救而不予帮助的村委会主任，还是看似礼貌实则被买通的邮递员、猥琐的小卖部老板等等，整部电影把村民的无知、冷漠、法盲血淋淋地展现到底。<br><br>最可怕的是当警察来救雪梅时，全村人集体出动阻挠，甚至以动武威胁。德贵无视警察的手枪，“犯啥法？你打，朝这打”，黄母也耍起无赖，“你们要把人带走，从我身上压过去算了”。看到这里突然觉得似曾相识。即使身处城市的我们，隔三差五依旧能看到类似的人、事。<br><br>不得不说，李杨是勇敢的，将社会最真实的一面毫无粉饰地展示出来。即使是现在，中国拐卖妇女的现象依旧存在，而且屡见不鲜。就同电影一样，村中的人们不认为这是犯法，而是天经地义，甚至就在电影拍摄时就有当地村民恬不知耻地问李杨：“那个女娃娃（女主角）长得不错，干脆就卖给我吧。”他们被山遮蔽了双眼，不以无知为耻，麻木不仁，上下同谋。<br><br>起初我心里是无比的愤怒，但是看到黄母为了不让雪梅堕胎而给雪梅下跪我又有了反思。村民们想要的无非是传宗接代，尽管他们的道德观不符合现代的标准，但他们的目的也不过如此。所谓“穷山恶水出刁民”，我认为村民的暴力，也是由于极度的不安全感。因为长期的与世隔绝，他们知道自己是跟不上时代的，是社会的最弱者，所以只能通过暴力、无赖来声明自己的权益。其实仔细想一想，他们不是不知道拐卖妇女是犯法，而是选择麻木，上下一气，因为他们都是一条绳上的蚂蚱。他们是既可恨又可悲的。<br><br>所以整部电影的罪人，我认为非人贩子莫属。</p><h2 id="再说雪梅"><a href="#再说雪梅" class="headerlink" title="再说雪梅"></a>再说雪梅</h2><p>其实电影中雪梅的设定是大学生就让我有些怀疑，因为即使是90年代，大学生也不至于会轻易相信一个人贩子的话到山里吧，要知道90年代的大学生是多么稀有，能力多强不说，至少在最基础的判断力上也不会那么愚蠢。<br><br>不过可能电影就是这样，不能以过分理性的眼光去评判，只要体会到导演想传达的感情和思想就可以了。从这个角度看，雪梅无疑是悲惨的，尤其是海外版结局，最终一刀砍向德贵。她的命运依旧没有被改变。不过这也更加贴近现实。毕竟被强制封闭在这山里那么久，忍受身体、精神上的虐待，经历种种绝望，她心里一定早有怒火，只是无法宣泄。从电影中雪梅给德贵拿毛巾那处就可以看出，她其实早有杀掉德贵的念头。即使是大学生，处在那样充满暴力的环境中久了，也会被同化，因为那里只有暴力才能解决问题。<br><br>对这个角色，我不想多说，只是替她惋惜。有哪个女生不希望自己能够享受更好的物质生活，能够嫁给自己心爱的人，如果她没有轻信人贩子，她的生活会是无限美好的，前途也是不可限量的。正是这种巨大的反差突出了这种矛盾。随着剧情的发展，看着雪梅一步步从清纯的少女，到年仅20多岁就看起来像大婶，心里无比叹息。<br><br>而目前在中国，依然有很多这样活生生的例子，它们也许就发生在我们老家，也许就是哪个婶婶、奶奶，就如上文说的村中其他被拐卖进来的女人一样，她们不像雪梅，大多数只能选择妥协，甚至有些还觉得在那里挺好。<br><br>有趣的是，影片最后打了一行字幕：“中国公安机关一直严厉打击拐卖妇女的犯罪活动，解救出无数被拐卖的妇女，并将犯罪分子绳之以法。”怎么看怎么像是讽刺。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;观《盲山》有感&quot;&gt;&lt;a href=&quot;#观《盲山》有感&quot; class=&quot;headerlink&quot; title=&quot;观《盲山》有感&quot;&gt;&lt;/a&gt;观《盲山》有感&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;不是影评，只是观后感&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天看了《
      
    
    </summary>
    
    
      <category term="movies" scheme="https://blog.markeyme.cn/tags/movies/"/>
    
  </entry>
  
  <entry>
    <title>好好写代码</title>
    <link href="https://blog.markeyme.cn/2018/02/08/%E5%A5%BD%E5%A5%BD%E5%86%99%E4%BB%A3%E7%A0%81%E5%BD%92%E6%A1%A3/"/>
    <id>https://blog.markeyme.cn/2018/02/08/好好写代码归档/</id>
    <published>2018-02-08T06:30:16.000Z</published>
    <updated>2018-07-30T14:29:20.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="好好写代码"><a href="#好好写代码" class="headerlink" title="好好写代码"></a>好好写代码</h1><p>作为一个刚写代码不久的小菜鸟，工作的半年多让我越发意识到提高代码质量的重要性。从前只会关注实现功能，慢慢的开始关注性能，现阶段则发现其实还有很多细节也是（如可读性、易用性、可维护性、一致性）提高代码质量的关键。“实现功能”跟“优雅地实现功能”是两码事。</p><p>大部分归纳自网络，将多篇文章的观点汇总加工了一下，也融合了一些个人的见解。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ul><li>单一职责原则</li><li>易用性原则</li><li>可读性原则</li><li><p>复杂性守恒原则：无论你怎么写代码，复杂性都是不会消失的</p><blockquote><p>注：如果逻辑很复杂，那么代码看起来就应该是复杂的。如果逻辑很简单，代码看起来就应该是简单的。</p></blockquote></li></ul><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>面向对象五大设计模式基本原则之一。即<strong>一部分代码只应该用于某一个特定功能，不应与其他功能耦合在一起</strong>。</p><p>假设你的一个function同时实现了功能a和功能b，之后需求变更，你需要修改功能a，但是因为这两个功能都在一个function里，你就不得不再去确认是否会影响到功能b。这就造成了不必要的成本。</p><p>如下我总结了三个拆分代码的原则：</p><h4 id="“and”原则"><a href="#“and”原则" class="headerlink" title="“and”原则"></a>“and”原则</h4><p>当你为你的方法命名时不得不加上“and”时，就该考虑考虑是不是要把这个方法拆分一下了。</p><h4 id="“100”原则"><a href="#“100”原则" class="headerlink" title="“100”原则"></a>“100”原则</h4><p>当你的一个function超过一百行时，一定要进行拆分了。</p><blockquote><p>注：这里的100可能有点多，只是对我个人而言，100算是我的极限，总之就是绝对不要将一个函数写的太长。</p></blockquote><h4 id="命令、查询拆分原则"><a href="#命令、查询拆分原则" class="headerlink" title="命令、查询拆分原则"></a>命令、查询拆分原则</h4><p>我们开发中大部分操作可以总结为“命令”和“查询”，如写cookie、修改data、发送post请求都可以叫“命令”，而读取cookie、ajax获取数据则认为是“查询”操作。</p><p>函数式编程中讲究“数据不可变”，即：</p><blockquote><p>只有纯的没有副作用的函数，才是合格的函数。</p><p>副作用：指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量）或修改参数。</p></blockquote><p>好处是使得开发更加简单，可回溯，测试友好，减少了任何可能的副作用。</p><p>将“命令”与“查询”拆分实际上就是函数式编程思想的部分体现，参考如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> firstName = <span class="built_in">document</span>.querySelector(<span class="string">"#firstName"</span>).value;</span><br><span class="line">    firstName = firstName.toLowerCase();</span><br><span class="line">    setCookie(<span class="string">"firstName"</span>, firstName);</span><br><span class="line">    <span class="keyword">if</span> (firstName === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> activeFirstName = getFirstName();</span><br></pre></td></tr></table></figure><p>通过名字来看，该方法是用于获取first name的，但实际上它还设置了cookie，这是我们没有预料的。对于一个“查询”方法，它不应该有任何修改方法外变量的行为，即“副作用”。更好的写法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> firstName = <span class="built_in">document</span>.querySelector(<span class="string">"#firstName"</span>).value</span><br><span class="line">    <span class="keyword">if</span> (firstName === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">setCookie(<span class="string">"firstName"</span>, getFirstName().toLowerCase());</span><br></pre></td></tr></table></figure><p>一目了然，getFirstName只返回firstName，而设置cookie操作在它之外进行。</p><h3 id="易用性原则"><a href="#易用性原则" class="headerlink" title="易用性原则"></a>易用性原则</h3><h4 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h4><p>这里的简单，主要归结为function的一些设计原则，有如下几点：调用简单、易理解、减少记忆成本、参数处理。</p><p>如下，仅仅想实现修改dom颜色、宽度等属性，原生代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#id'</span>).style.color = <span class="string">'red'</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#id'</span>).style.width = <span class="string">'123px'</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#id'</span>).style.height = <span class="string">'456px'</span></span><br></pre></td></tr></table></figure><p>而封装过后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">selector, color, width, height</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).style.color = color</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).style.width = width</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).style.height = height</span><br><span class="line">&#125;</span><br><span class="line">a(<span class="string">'#a'</span>, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><p>瞬间变得<strong>简单可用</strong>了 ~</p><p>但该方法还存在一个问题，那就是命名太抽象了。。。除了开发者自己以外不可能有人在不看源码的情况下一眼看出这个方法a是干嘛的。那么咱再把这个方法名改写得更<strong>易理解</strong>一点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">letSomeElementChange</span>(<span class="params">selector, color, width, height</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).style.color = color</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).style.width = width</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).style.height = height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就能一目了然该方法的作用 ~ 不过仍有可优化的地方。这么长的方法名谁记得住，要<strong>减少记忆成本</strong>啊，再改个名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setElement</span>(<span class="params">selector, color, width, height</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).style.color = color</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).style.width = width</span><br><span class="line">  <span class="built_in">document</span>.querySelector(selector).style.height = height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，目前这个方法已经满足它的职责并且很好用了，但还觉得怪怪的。这一坨参数太碍眼。。。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setElement</span>(<span class="params">selector, opt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; color, width, height &#125; = opt</span><br><span class="line">  color &amp;&amp; <span class="built_in">document</span>.querySelector(selector).style.color = color</span><br><span class="line">  width &amp;&amp; <span class="built_in">document</span>.querySelector(selector).style.width = width</span><br><span class="line">  height &amp;&amp; <span class="built_in">document</span>.querySelector(selector).style.height = height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把多个参数合并一下，并在内部做兼容处理，这个方法便易用多了。即使不传第二个参数也不会有任何副作用。</p><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>假如有这样一个方法，获取歌曲列表，并将其设置到div的innerText中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSongs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> $.get(<span class="string">'/songs).then((response) &#123;</span></span><br><span class="line"><span class="string">      div.innerText = response.songs</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这就违背了方法的<strong>表里一致性</strong>，也违背了上文的<strong>单一职责原则</strong>中<strong>命令、查询拆分原则</strong>，因为它不仅获取了歌单，同时还修改了innerText，要让其更合理：</p><ul><li>要么换个名字</li><li>要么拆分为两个方法</li></ul><h4 id="低耦合"><a href="#低耦合" class="headerlink" title="低耦合"></a>低耦合</h4><p><strong>耦合是衡量一个程序单元对其他程序单元的依赖程度</strong>。耦合（或高耦合）是应该极力避免的。如果你发现自己正在复制和粘贴代码并进行小的更改，或者重写代码，因为其他地方发生了更改，这就是高耦合的体现。</p><p>耦合会严重影响代码的复用性及可扩展性，让后人维护时不得不修改甚至重写这部分代码，不仅浪费时间还会导致仓储中又多出一块类似的代码，很容易让人迷惑。</p><p>同时，修改耦合度高的代码时经常会牵一发而动全身，如果修改时没有理清这些耦合关系，那么带来的后果可能会是灾难性的，特别是对于需求变化较多以及多人协作开发维护的项目，修改一个地方会引起本来已经运行稳定的模块错误，严重时会导致恶性循环，问题永远改不完，开发和测试都在各种问题之间奔波劳累，最后导致项目延期，用户满意度降低，成本也增加了，这对用户和开发商影响都是很恶劣的，各种风险也就不言而喻了。</p><h4 id="高内聚"><a href="#高内聚" class="headerlink" title="高内聚"></a>高内聚</h4><blockquote><p><strong>不应该将没有任何联系的东西堆到一起。</strong></p></blockquote><p><strong>内聚是一个类中变量与方法连接强度的尺度</strong>。高内聚是值得要的，因为它意味着类可以更好地执行一项工作。低内聚是不好的，因为它表明类中的元素之间很少相关。每个方法也应该高内聚，大多数的方法只执行一个功能，不要在方法中添加‘额外’的指令，这样会导致方法执行更多的函数，同时也违反了上文的<strong>单一职责原则</strong>。</p><p><strong>低内聚的体现</strong>：如果属性没有被类中的多个方法使用，这可能是低内聚的标志。同样，如果方法在几种不同的情况下不能被重用，或者如果一个方法根本不被使用，这也可能是低内聚的一个标志。</p><p><strong>高内聚有助于缓解高耦合，高耦合是需要高内聚的标志</strong>。但是，如果两个问题同时存在，应当选择内聚的方式。对于开发者来说，高内聚通常比低耦合更有帮助，尽管两者通常可以一起完成。</p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><ul><li>可预见的错误：诸如ajax回调、函数参数，这类问题很好解决，只需在开发时多考虑一步，对各种极端情况做好兼容即可。</li><li>不可预见的错误：类似兼容性问题，这类问题无法在开发时准确预见的错误，可以准备好抛错，console.error/log/warn，最后你还可以为自己的程序留些后路: try…catch。</li></ul><h3 id="可读性原则"><a href="#可读性原则" class="headerlink" title="可读性原则"></a>可读性原则</h3><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>命名应该保证别人通过名称一眼就能知道这个变量保存的是什么，或者这个方法是用来做什么的。</p><ul><li><p>普通变量、属性用名词如下：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Frank'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> student = &#123;</span><br><span class="line">    grade: <span class="number">3</span>,</span><br><span class="line">    class: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>bool变量、属性用（形容词）或者（be动词）或者（情态动词）或者（hasX），如下：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    dead: <span class="literal">false</span>, <span class="comment">// 如果是形容词，前面就没必要加 is，比如isDead 就很废话</span></span><br><span class="line">    canSpeak: <span class="literal">true</span>, <span class="comment">//情态动词有 can、should、will、need 等，情态动词后面接动词</span></span><br><span class="line">    isVip: <span class="literal">true</span>, <span class="comment">// be 动词有 is、was 等，后面一般接名词</span></span><br><span class="line">    hasChildren: <span class="literal">true</span>, <span class="comment">// has 加名词</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>普通函数、方法用（动词）开头：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    run()&#123;&#125;, <span class="comment">// 不及物动词</span></span><br><span class="line">    drinkWater()&#123;&#125;, <span class="comment">// 及物动词</span></span><br><span class="line">    eat(foo)&#123;&#125;, <span class="comment">// 及物动词加参数（参数是名词）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回调、钩子函数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    beforeDie()&#123;&#125;,</span><br><span class="line">    afterDie()&#123;&#125;,</span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    willDie()&#123;&#125;</span><br><span class="line">    dead()&#123;&#125; <span class="comment">// 这里跟 bool 冲突，你只要不同时暴露 bool dead 和函数 dead 就行，怕冲突就用上面的 afterDie</span></span><br><span class="line">&#125;</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, onButtonClick)</span><br><span class="line"><span class="keyword">var</span> component = &#123;</span><br><span class="line">    beforeCreate()&#123;&#125;,</span><br><span class="line">    created()&#123;&#125;,</span><br><span class="line">    beforeMount()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>命名一致性</p><ul><li>顺序一致性：比如 updateContainerWidth 和 updateHeightOfContainer 的顺序就令人很别扭</li><li><strong>时间一致性</strong>：有可能随着代码的变迁，一个变量的含义已经不同于它一开始的含义了，这个时候你需要及时改掉这个变量的名字。<br>这一条是最难做到的，因为写代码容易，改代码难。如果这个代码组织得不好，很可能会出现牵一发而动全身的情况（如全局变量就很难改）</li></ul></li></ul><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>不需要多花哨，只要把作用、用法描述清楚即可。方法的标准注释应该如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [function_name description]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; argument [description]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;          [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_name</span>(<span class="params">argument</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将方法的参数与返回值都写清楚，我目前用的IDE是sublime，使用<a href="https://atom.io/packages/docblockr" target="_blank" rel="noopener">Docblockr</a>插件可以自动生成格式化注释，很方便。</p><h3 id="Bad-Smell"><a href="#Bad-Smell" class="headerlink" title="Bad Smell"></a>Bad Smell</h3><p>项目中我们经常能够遇这类代码，它们仍可用，但是很“臭”，国外管这类代码有一个统称，即“bad smell”。如下这类代码可以说是很“臭”了：</p><ul><li>表里不一的代码</li><li>过时的注释</li><li>逻辑很简单，但是看起来很复杂的代码</li><li>重复的代码</li><li>相似的代码</li><li>总是一起出现的代码</li><li>未使用的依赖</li><li>不同风格的代码</li></ul><h3 id="样式规范"><a href="#样式规范" class="headerlink" title="样式规范"></a>样式规范</h3><ol><li><strong>正确命名</strong>：class必须用“-”写法，不要用驼峰和下划线。</li><li><strong>正确嵌套</strong>：正常情况下一定要将class嵌套闭合，否则就相当于添加到全局，如果有重复命名的class就会受影响。</li><li><strong>拒绝copy</strong>：如果想复用已有的样式，直接在原有class上用“,”语法分割，就能应用，不要再copy一份样式，会让两份样式都被应用，就要考虑样式覆盖的问题，很不友好。</li><li><strong>滥用class</strong>：没有必要加的class不要加，每个class的添加都应该有明确理由。滥用class的话可能会导致样式覆盖，不该应用这个样式的地方用了某个样式。</li><li><p>慎用 <strong>!important</strong>，会强行覆盖所有同属性样式，一旦使用后会让代码难以维护，开发过程中绝对不要依赖该方法。如下总结了一些使用 <strong>!important</strong>的经验：</p><ul><li>一定要优化考虑使用样式规则的优先级来解决问题而不是 !important</li><li>只有在需要覆盖全站或外部 css（例如引用的 ExtJs 或者 YUI ）的特定页面中使用 !important</li><li>解决紧急线上问题可以使用，但之后也要尽快用可维护的方式将代码替换回来</li><li>永远不要在全站范围的 css 上使用 !important</li><li>永远不要在你的插件中使用 !important</li></ul></li></ol><h2 id="说得容易，做起来难"><a href="#说得容易，做起来难" class="headerlink" title="说得容易，做起来难"></a>说得容易，做起来难</h2><h3 id="破窗效应"><a href="#破窗效应" class="headerlink" title="破窗效应"></a>破窗效应</h3><blockquote><p>此理论认为环境中的不良现象如果被放任存在，会诱使人们仿效，甚至变本加厉。一幢有少许破窗的建筑为例，如果那些窗不被修理好，可能将会有破坏者破坏更多的窗户。最终他们甚至会闯入建筑内，如果发现无人居住，也许就在那里定居或者纵火。一面墙，如果出现一些涂鸦没有被清洗掉，很快的，墙上就布满了乱七八糟、不堪入目的东西；一条人行道有些许纸屑，不久后就会有更多垃圾，最终人们会视若理所当然地将垃圾顺手丢弃在地上。这个现象，就是犯罪心理学中的<strong>破窗效应</strong>，在编程领域同样存在。</p></blockquote><p>要做到：<strong>只要是经过你手的代码，都会比之前好一点。</strong></p><p>参考文章：</p><ul><li><a href="http://www.cnblogs.com/constantince/p/5580003.html" target="_blank" rel="noopener">javascript的api设计原则</a></li><li><a href="http://alistapart.com/article/coding-with-clarity" target="_blank" rel="noopener">Coding with Clarity</a></li><li><a href="https://dev.to/raulavila/dont-leave-broken-windows" target="_blank" rel="noopener">Don’t leave broken windows</a></li><li><a href="https://segmentfault.com/a/1190000008780076" target="_blank" rel="noopener">从JS对象开始，谈一谈“不可变数据”和函数式编程</a></li><li><a href="https://segmentfault.com/a/1190000012972191" target="_blank" rel="noopener">重构 - 代码优化技巧</a></li><li><a href="https://www.w3cplus.com/css/the-important-css-declaration-how-and-when-to-use-it.html" target="_blank" rel="noopener">如何和何时使用CSS的!important</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity" target="_blank" rel="noopener">css优先级</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;好好写代码&quot;&gt;&lt;a href=&quot;#好好写代码&quot; class=&quot;headerlink&quot; title=&quot;好好写代码&quot;&gt;&lt;/a&gt;好好写代码&lt;/h1&gt;&lt;p&gt;作为一个刚写代码不久的小菜鸟，工作的半年多让我越发意识到提高代码质量的重要性。从前只会关注实现功能，慢慢的开始关注性
      
    
    </summary>
    
    
      <category term="coding" scheme="https://blog.markeyme.cn/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>markey</title>
    <link href="https://blog.markeyme.cn/2018/01/16/markey/"/>
    <id>https://blog.markeyme.cn/2018/01/16/markey/</id>
    <published>2018-01-16T13:13:16.000Z</published>
    <updated>2018-01-17T14:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小站终于搭好啦"><a href="#小站终于搭好啦" class="headerlink" title="小站终于搭好啦"></a>小站终于搭好啦</h1><p>为了纪念这意义重大的时刻，一定要写篇文章庆祝下，主题不是别的，就是我。</p><h2 id="歪某某—-一个努力的前端程序猿兼鼓手"><a href="#歪某某—-一个努力的前端程序猿兼鼓手" class="headerlink" title="歪某某— 一个努力的前端程序猿兼鼓手"></a>歪某某— 一个努力的前端程序猿兼鼓手</h2><p>称谓：</p><ul><li>大头（因为姓氏的缘故，这个昵称是被用的最久的，贯穿我的整个童年、少年时代…）</li><li>歪**（高中时开始用，主要在网上用，没什么含义，好玩而已）</li><li>markey（码名：即作为开发者的昵称）</li></ul><p>2017年6月25日毕业于东北林业大学，信息管理与信息系统专业（一半计算机一半管理）。大学期间没参与任何校组织（因为觉得官僚），倒是把一大半精力放在了社团上，一个是异族摇滚社，一个是606软件工作室。可以说这两个社团的经历决定了我现在的路。</p><p>学生时代喜欢安静，不太参与社交，造成了现在表达能力欠佳。很多时候想法有了，不知如何表达，非常无奈啊。工作后这个问题更加凸显出来，最近正在慢慢改进。</p><p>从小到大就一直有股倔劲，对于自己喜欢的事，非常执着、我行我素。学生时代可以总结为这几件事：</p><ul><li>小学：魔兽3、cs</li><li>初中：篮球</li><li>高中：学习</li><li>大学：音乐、前端</li></ul><p>小学时是个网瘾少年，立志成为sky那样的电竞选手，天天打魔兽、cs。自以为在朋友圈中水平尚佳，但也因此成绩渣的一逼，升学考试没能进入重点班。</p><p>初中渐渐放弃电竞，又开始沉迷篮球，模板为NBA伟大射手Ray.Allen。初二还参加过训练营，见识到世界之大后备受打击，遂专心学习。</p><p>高中时代由于篮球打得还行，学习成绩也不错，先后被几个妹子暧昧，但没一个有结果。那时候脑子里就只有学习…情商啊…</p><p>附一张高中时代仅有的图，被邻桌偷拍的：<br><img src="/assets/high_school.jpeg" alt="高中"></p><p>大学时的经历着实决定了我现在的方向。加入了异族摇滚社让我体会到了责任与担当，也给予了我终生的爱好；加入软件工作室让我接触了前端，进入了互联网行业，也学会了一门养活自己的本事。</p><p>因为喜欢日本视觉系摇滚，大学演出特意让左边这个漂亮的妹子给画了个非常视觉系的浓妆…后来还画过几次，但都没这次成功。<br><img src="/assets/college_1.jpeg" alt="浓妆"></p><p>如今，已工作半年，每天沉迷工作无法自拔，只想努力成长，早日成为大牛。之后有时间了，还计划继续玩个乐队，没事儿录个视频、排排练，也是极好的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;小站终于搭好啦&quot;&gt;&lt;a href=&quot;#小站终于搭好啦&quot; class=&quot;headerlink&quot; title=&quot;小站终于搭好啦&quot;&gt;&lt;/a&gt;小站终于搭好啦&lt;/h1&gt;&lt;p&gt;为了纪念这意义重大的时刻，一定要写篇文章庆祝下，主题不是别的，就是我。&lt;/p&gt;
&lt;h2 id=&quot;歪某
      
    
    </summary>
    
    
      <category term="life" scheme="https://blog.markeyme.cn/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>git总结</title>
    <link href="https://blog.markeyme.cn/2018/01/15/git%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.markeyme.cn/2018/01/15/git总结/</id>
    <published>2018-01-15T13:55:45.000Z</published>
    <updated>2018-03-21T09:57:06.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GIT学习笔记"><a href="#GIT学习笔记" class="headerlink" title="GIT学习笔记"></a>GIT学习笔记</h1><p>仅为本人在工作过程中学习git的一些经验总结，还是git菜鸟一只，有更好的见解欢迎留言 ~</p><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><ol><li>在解冲突时一定要注意，对自己不熟悉的代码要问问是谁写的在解. 如果出现问题，用 git merge –abort 可以将冲突文件退回到merge之前的状态</li><li>在新建一个开发分支时，一定要基于master分支建，不要让其他分支上的代码掺入你的开发分支</li><li>若想更新本地仓库中的分支或tag，用 <strong>git fetch [远程仓库]</strong> 则将远程仓库的所有更新取回本地，<strong>git fetch [远程仓库] &lt;分支名></strong> 还可以在后面制定分支名，表示只取得该分支的更新，<strong>git fetch –t</strong> 表示取得所有更新及tag</li></ol><h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><ol><li><strong>git config –list</strong> 查看当前的配置项；</li><li><strong>git config –unset [配置键].[配置名]</strong> 删除某项配置；</li><li><strong>git config –global alias.br branch</strong> 设置br为branch命令快捷命令(全局)；</li></ol><h2 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h2><ol><li>要删除远端分支，可以 <strong>git push origin :feature-index-1207</strong>，在分支前加个冒号表示为空分支，推送一个空分支到远端就删除了这个分支；</li><li>git是支持将本地分支push到远程的另一个分支的<br><strong>git push origin develop:master -f</strong><br>将本地的develop push到远端的master分支，<strong>-f为强制标记</strong></li><li><strong>git branch –m 旧分支名 新分支名</strong> 重命名某个分支</li><li>若push之前没有pull远端代码，并且远端有修改的话，是不能push上去的，会提示你先pull再push.</li><li><p><strong>git branch –set-upstream-to origin/[branch]</strong> 设置本地分支跟踪远端分支，<strong>当这样设置后，pull以及push都无需指定origin [branch]了</strong>。</p><blockquote><p><strong>注</strong>：push本地新建的分支到远端，可以用<strong>git push –u origin [branch]</strong>，这样就自动跟踪了远端的这个分支 </p></blockquote></li><li><p><strong>git branch –unset-upstream</strong> 清除当前分支的追踪分支</p></li><li><strong>git branch –track [branch] [remote-branch]</strong> 新建一个本地分支，并与远端分支建立追踪关系</li><li>新建的开发分支不用时刻保持跟master最新的关系，合并到master的时候只是把你的修改合并，并不会将你的分支的其他代码也合并，就是说master中代码还是最新的，并且添加上了你的分支的修改，若有冲突则会合并失败，需要解冲突。</li><li>使用<strong>git rebase [分支名]</strong>“干净地”合并。与merge一样，主要都是为了保持开发分支与master同步。只不过merge会保留很多无用的commit，并且commit的顺序是根据时间排序的，而rebase默认则是将开发分支的commit排在最后（尽管可能commit时间比master某些commit早）。<ul><li>当rebase过程中有冲突时可以用<strong>git rebase –abort</strong>、<strong>git rebase –continue</strong>等命令控制rebase流程</li><li>使用<strong>git rebase -i [分支名]</strong>可以做很多commit相关操作，如可以修改commit message、将多个commit合并为一个等</li></ul></li><li>当本地有修改未添加到暂存区或提交时，会无法checkout到已有分支，而用<strong>git checkout -b [新分支名]</strong>命令切换到新分支则没问题，并会把修改带到新分支<ul><li>该问题也可以使用<strong>git stash</strong>命令解决，该命令将工作区的修改保存，通过<strong>git stash list</strong>可以查看当前保存的所有操作</li><li><strong>git stash pop [stash序号]</strong>恢复保存的工作区修改到当前分支</li><li><strong>git stash clear</strong>清空所有stash</li></ul></li><li><strong>git merge –squash [分支名]</strong>将本地另一个分支所有提交合并为一个，并添加到当前分支的暂存区</li></ol><h2 id="对比及回退"><a href="#对比及回退" class="headerlink" title="对比及回退"></a>对比及回退</h2><ol><li><p>git比对本次跟上次提交的区别: <strong>git diff HEAD HEAD^ –stat</strong>(显示的不详细)；</p><blockquote><p><strong>注</strong>：git diff 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。(若没有提交暂存区，则会比对上次提交的快照)<br></p><p><strong>注</strong>：若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 <strong>git diff –cached</strong> 命令。</p></blockquote></li><li><p><strong>git reset –hard [commit_id]</strong> 回退到某次的commit状态，并将<strong>本地源码也恢复到那次commit的状态</strong><br><br><strong>git reset –soft [commit_id]</strong> 回退到某次的commit状态，但<strong>本地源码保持不变，并保存到暂存区</strong>，如需提交，重新提交即可<br><br><strong>git reset [commit-id]（git reset –mixed [commit-id]）</strong> 回退到某次的commit状态，但本地源码保持不变，如需提交，重新提交即可<br><br><strong>git reset HEAD <file\></file\></strong> 撤销已暂存的文件<br><br><strong>git reset HEAD~[n]</strong> 撤销到倒数第n次提交<br><br><strong>git checkout <file\></file\></strong> 摒弃对文件的修改(若无暂存状态，则会退到上次commit；  若有，则回退到上次暂存状态)<br><br><strong>git reset [commit-id | 分支名] <file-name\></file-name\></strong> 也可以将单个文件恢复到指定提交，但无法使用以上模式，<strong>当前分支修改保持不变，reset到的目标分支加入到暂存区</strong></p><blockquote><p><strong>注</strong>：git reset 到某次commit都会删除git log中那次的commit信息，即回退后就无法再回到之前的commit了<br></p><p><strong>注</strong>：git reset 也可以reset到<em>另一个分支</em>的最后一次提交状态，如: <strong>git reset –hard develop</strong>，同时也可以reset到远端分支的最后一次提交，如<strong>git reset –hard origin/[远端分支名]</strong><br></p></blockquote></li><li><p><strong>git revert HEAD</strong> 回退到最近一次提交的<strong>前一次提交</strong><br><br><strong>git revert HEAD~[n]</strong> 回退到倒数第n次提交的<strong>前一次提交</strong><br><br><strong>git revert [commit_id]</strong> 回退到指定提交的<strong>前一次提交</strong><br></p><blockquote><p><strong>注</strong>：revert相比reset更安全，因为它是生成一次新的提交记录，保留原有的提交记录。</p><p><strong>注</strong>：经测试，这里所说的<strong>前一次提交</strong>是指代码是前一次提交的状态，但显示revert到的commit_id还是指定的commit_id。这一点要跟reset区分开。</p></blockquote></li><li><strong>git commit –amend</strong> 将暂存区中的更改更新到最近一次提交（不会产生新的提交记录）<blockquote><p><strong>注</strong>：若提交时忘了提交某些修改可以用该方法补救</p></blockquote></li><li><strong>git log -p [file]</strong> 查看指定文件每次提交的diff</li><li><strong>git log -g</strong> 按照操作顺序查看所有操作，包括checkout、commit、merge、reset等等。当分支被误删，想要恢复那个分支的代码时，该指令很有效。使用 <strong>git branch [分知名] [commit_id]</strong> 即可恢复分支。<blockquote><p><strong>注</strong>：添加到暂存区是不会有记录的</p></blockquote></li><li><strong>git cherry-pick [commit_id]</strong>可以将其他分支上的提交，在当前分支再提交一次，生成的新commit_id不同</li></ol><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p><strong>原理</strong>：<br><br>你必须为自己创建一对<em>密匙</em>，并把<em>公钥</em>放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，<strong>请求用你的<em>公钥</em>进行安全验证</strong>。服务器收到请求之后，先在你在该服务器的目录下寻找你的<em>公钥</em>，然后把它和你发送过来的公钥进行比较。如果两个一致，服务器就用<strong>公钥加密“质询”（challenge）</strong>并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的<em>密钥解密</em>再把它发送给服务器。<br><strong>SSH key(密钥对)</strong>：<br><br>是git对用户进行身份验证的重要根据，若该用户的电脑上没有ssh key，或者有但是没有添加至ssh agent或你的git account，是无法连接到github进行远端操作的(可通过<strong>ssh -T git@github.com</strong> 命令才验证)<br><br>因此，需要创建ssh key并添加至你的git account。<br>步骤如下：</p><ol><li><strong>本地创建ssh key</strong><br><br>在git bash中输入 <strong>ssh-keygen -t rsa -C “your email address”</strong>命令，然后回车，再输入两次密码即可(该密码在你设置ssh key 到git account时会用到)</li><li><strong>添加到你的ssh agent上</strong><br><br>先检测ssh-agent是否运行 <strong>$ eval $(ssh-agent -s)</strong><br>添加SSH key到ssh-agent <strong>$ ssh-add 你的密钥文件路径(一般是id_rsa)</strong></li><li><p>登录到你的git账户，在settings目录下找到SSH key设置，将你的公钥复制到key选项中，title随意，完事 ~<br></p><blockquote><p><strong>注</strong>：可以通过<strong>ssh-add -l</strong>命令判断当前正在使用的ssh-key，如果有在使用的key，则会输出该key的fingerprint。并且默认的~/.ssh/id_rsa、 ~/.ssh/id_dsa以及 ~/.ssh/identity是自动加入SSH authentication agent的，因此无需再手动ssh-add，如果你使用的是其他名字的key，则要手动加入！</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GIT学习笔记&quot;&gt;&lt;a href=&quot;#GIT学习笔记&quot; class=&quot;headerlink&quot; title=&quot;GIT学习笔记&quot;&gt;&lt;/a&gt;GIT学习笔记&lt;/h1&gt;&lt;p&gt;仅为本人在工作过程中学习git的一些经验总结，还是git菜鸟一只，有更好的见解欢迎留言 ~&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="coding" scheme="https://blog.markeyme.cn/tags/coding/"/>
    
      <category term="git" scheme="https://blog.markeyme.cn/tags/git/"/>
    
  </entry>
  
</feed>
